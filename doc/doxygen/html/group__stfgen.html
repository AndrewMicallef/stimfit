<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>stimfit: Generic stimfit classes and functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">stimfit&#160;<span id="projectnumber">0.10.5</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Generic stimfit classes and functions</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChannel.html">Channel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classChannel.html" title="A Channel contains several data Sections  representing observations of the same physical quantity...">Channel</a> contains several data <a class="el" href="classSection.html">Sections </a> representing observations of the same physical quantity.  <a href="classChannel.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRecording.html">Recording</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the data within a file.  <a href="classRecording.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSection.html">Section</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a continuously sampled sweep of data points.  <a href="classSection.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstf_1_1Table.html">stf::Table</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A table used for printing information.  <a href="classstf_1_1Table.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1parInfo.html">stf::parInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about parameters used in <a class="el" href="structstf_1_1storedFunc.html" title="Function used for least-squares fitting.">storedFunc</a>.  <a href="structstf_1_1parInfo.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1storedFunc.html">stf::storedFunc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used for least-squares fitting.  <a href="structstf_1_1storedFunc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1UserInput.html">stf::UserInput</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents user input from dialogs that can be used in plugins.  <a href="structstf_1_1UserInput.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstf_1_1Event.html">stf::Event</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the attributes of an event.  <a href="classstf_1_1Event.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1PyMarker.html">stf::PyMarker</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A marker that can be set from Python.  <a href="structstf_1_1PyMarker.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1Plugin.html">stf::Plugin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined plugin.  <a href="structstf_1_1Plugin.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1Extension.html">stf::Extension</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined Python extension.  <a href="structstf_1_1Extension.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1ifstreamMan.html">stf::ifstreamMan</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resource manager for ifstream objects.  <a href="structstf_1_1ifstreamMan.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1ofstreamMan.html">stf::ofstreamMan</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resource manager for ofstream objects.  <a href="structstf_1_1ofstreamMan.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstf_1_1txtImportSettings.html">stf::txtImportSettings</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Text file import filter settings.  <a href="structstf_1_1txtImportSettings.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function<br class="typebreak"/>
&lt; double(double, const <br class="typebreak"/>
Vector_double &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga11d6ec55abceacf5fdd47f9fc889d9a3">stf::Func</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function taking a double and a vector and returning a double.  <a href="#ga11d6ec55abceacf5fdd47f9fc889d9a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga77f3e621f1771784f2befaeb3d1ac4fb"></a><!-- doxytag: member="stfgen::Jac" ref="ga77f3e621f1771784f2befaeb3d1ac4fb" args="" -->
typedef boost::function<br class="typebreak"/>
&lt; Vector_double(double, const <br class="typebreak"/>
Vector_double &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga77f3e621f1771784f2befaeb3d1ac4fb">stf::Jac</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The jacobian of a stf::Func. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga775530afebda38e8138e8eb1401a0e01"></a><!-- doxytag: member="stfgen::Scale" ref="ga775530afebda38e8138e8eb1401a0e01" args="" -->
typedef boost::function<br class="typebreak"/>
&lt; double(double, double, <br class="typebreak"/>
double, double, double)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga775530afebda38e8138e8eb1401a0e01">stf::Scale</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling function for fit parameters. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga15ccefdb3c4b758564e73f080639ff98"></a><!-- doxytag: member="stfgen::Init" ref="ga15ccefdb3c4b758564e73f080639ff98" args="" -->
typedef boost::function&lt; void(const <br class="typebreak"/>
Vector_double &amp;, double, <br class="typebreak"/>
double, double, Vector_double &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga15ccefdb3c4b758564e73f080639ff98">stf::Init</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialising function for the parameters in stf::Func to start a fit. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66542f63882a99158a17cdc977eac5e8"></a><!-- doxytag: member="stfgen::Output" ref="ga66542f63882a99158a17cdc977eac5e8" args="" -->
typedef boost::function&lt; Table(const <br class="typebreak"/>
Vector_double &amp;, const <br class="typebreak"/>
std::vector&lt; <a class="el" href="structstf_1_1parInfo.html">stf::parInfo</a> &gt;<br class="typebreak"/>
, double)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga66542f63882a99158a17cdc977eac5e8">stf::Output</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the output of a fit into a <a class="el" href="classstf_1_1Table.html" title="A table used for printing information.">stf::Table</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa37601710b061d50b53ceeab1e7a9dd2"></a><!-- doxytag: member="stfgen::PluginFunc" ref="gaa37601710b061d50b53ceeab1e7a9dd2" args="" -->
typedef boost::function<br class="typebreak"/>
&lt; <a class="el" href="classRecording.html">Recording</a>(const <a class="el" href="classRecording.html">Recording</a> <br class="typebreak"/>
&amp;, const Vector_double <br class="typebreak"/>
&amp;, std::map&lt; <a class="el" href="classwxString.html">wxString</a>, double &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gaa37601710b061d50b53ceeab1e7a9dd2">stf::PluginFunc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classRecording.html" title="Represents the data within a file.">Recording</a>, do something with it, return the new <a class="el" href="classRecording.html" title="Represents the data within a file.">Recording</a>. <br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gae8845ae2aeaf4b742a905a2a5571fd5a">stf::direction</a> { <a class="el" href="group__stfgen.html#ggae8845ae2aeaf4b742a905a2a5571fd5aaf12a3d86708046ee92fa400c99fcbecb">stf::up</a>, 
<a class="el" href="group__stfgen.html#ggae8845ae2aeaf4b742a905a2a5571fd5aaccaa84903131c15d67e4f95298e68e2b">stf::down</a>, 
<a class="el" href="group__stfgen.html#ggae8845ae2aeaf4b742a905a2a5571fd5aa22cccef6520f7679886dc6d584805ce3">stf::both</a>, 
<a class="el" href="group__stfgen.html#ggae8845ae2aeaf4b742a905a2a5571fd5aab5df1157da4f45612d5815bc164e0931">stf::undefined_direction</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The direction of peak calculations. </p>
 <a href="group__stfgen.html#gae8845ae2aeaf4b742a905a2a5571fd5a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gad2d1acb3ac0c16ee32b5f4d3a1ab4abf">stf::cursor_type</a> { <br/>
&#160;&#160;<a class="el" href="group__stfgen.html#ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa1b879af00b1b8b8c4a195c0b27de3f0b">stf::measure_cursor</a>, 
<a class="el" href="group__stfgen.html#ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfad99eafbc283ce642e9ff607357c95e9b">stf::peak_cursor</a>, 
<a class="el" href="group__stfgen.html#ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa8c54633348bfe4fdeaf6c8ddf06fccba">stf::base_cursor</a>, 
<a class="el" href="group__stfgen.html#ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfab09f70483c5bed40addf3c21eb528afe">stf::decay_cursor</a>, 
<br/>
&#160;&#160;<a class="el" href="group__stfgen.html#ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfabb059a629fb7fbf5d9a3f83c44954b9b">stf::latency_cursor</a>, 
<a class="el" href="group__stfgen.html#ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfadb6eff6e3108c48f2dd357dc3b539238">stf::zoom_cursor</a>, 
<a class="el" href="group__stfgen.html#ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa28885ead48beb5a6da1810d391d41760">stf::event_cursor</a>, 
<a class="el" href="group__stfgen.html#ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa2794c8863a730fbd8e4dea7f93b8dfa7">stf::undefined_cursor</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Mouse cursor types. </p>
 <a href="group__stfgen.html#gad2d1acb3ac0c16ee32b5f4d3a1ab4abf">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga9a792b11c01e9429bfe2acd3e4ef108b">stf::zoom_channels</a> { <a class="el" href="group__stfgen.html#gga9a792b11c01e9429bfe2acd3e4ef108bafdaacd56a89cce6998f8fcc331b0f665">stf::zoomch1</a>, 
<a class="el" href="group__stfgen.html#gga9a792b11c01e9429bfe2acd3e4ef108baef0062d1da678e4771bf559b3dc1e537">stf::zoomch2</a>, 
<a class="el" href="group__stfgen.html#gga9a792b11c01e9429bfe2acd3e4ef108ba0c34eab028555c38760abc86b551b6c6">stf::zoomboth</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Determines which channels to scale. </p>
 <a href="group__stfgen.html#ga9a792b11c01e9429bfe2acd3e4ef108b">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga738f9934a45a9d2d81cb0a3de0375c99">stf::latency_mode</a> { <br/>
&#160;&#160;<a class="el" href="group__stfgen.html#gga738f9934a45a9d2d81cb0a3de0375c99a38b8edc5f8a706c23b6efd737aada25a">stf::manualMode</a> =  0, 
<a class="el" href="group__stfgen.html#gga738f9934a45a9d2d81cb0a3de0375c99a42837a2123b13815fb4ee3c005f2cac0">stf::peakMode</a> =  1, 
<a class="el" href="group__stfgen.html#gga738f9934a45a9d2d81cb0a3de0375c99abbb23ece92fe176e5358289e2b14f97e">stf::riseMode</a> =  2, 
<a class="el" href="group__stfgen.html#gga738f9934a45a9d2d81cb0a3de0375c99ae23bd76db1d3f2fd5ee275c5dc004283">stf::halfMode</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="group__stfgen.html#gga738f9934a45a9d2d81cb0a3de0375c99a216dce55e173d3838de785cf0a42d87e">stf::footMode</a> =  4, 
<a class="el" href="group__stfgen.html#gga738f9934a45a9d2d81cb0a3de0375c99a871047aafad5c561dbf5a77e80a7b174">stf::undefinedMode</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Latency cursor settings. </p>
 <a href="group__stfgen.html#ga738f9934a45a9d2d81cb0a3de0375c99">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gae034ed0eec6bdaba3b23d3b2184f799d">stf::latency_window_mode</a> { <a class="el" href="group__stfgen.html#ggae034ed0eec6bdaba3b23d3b2184f799da65ce55297aad4c581e70b239864c2a16">stf::defaultMode</a> =  0, 
<a class="el" href="group__stfgen.html#ggae034ed0eec6bdaba3b23d3b2184f799daf28fa2b9cdf5e498f1ed689e1d8d1934">stf::windowMode</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Latency window settings. </p>
 <a href="group__stfgen.html#gae034ed0eec6bdaba3b23d3b2184f799d">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gae703f7802498ae301ac058b94426900f">stf::filetype</a> { <br/>
&#160;&#160;<a class="el" href="group__stfgen.html#ggae703f7802498ae301ac058b94426900fa0136c00f38aa0ad185d30d7c845f38b5">stf::atf</a>, 
<a class="el" href="group__stfgen.html#ggae703f7802498ae301ac058b94426900fa5496504b8584246c4ee5820087f94be2">stf::abf</a>, 
<a class="el" href="group__stfgen.html#ggae703f7802498ae301ac058b94426900fa8140bedc5caf41a80dbbdb1bed69b799">stf::axg</a>, 
<a class="el" href="group__stfgen.html#ggae703f7802498ae301ac058b94426900fa653f7b20462a96d94629bf0a997f70f9">stf::ascii</a>, 
<br/>
&#160;&#160;<a class="el" href="group__stfgen.html#ggae703f7802498ae301ac058b94426900fa0eb892b5486c4452d4030cd8a6788457">stf::cfs</a>, 
<a class="el" href="group__stfgen.html#ggae703f7802498ae301ac058b94426900fa8b7b106321d7c7cad7791629bb4e11f9">stf::igor</a>, 
<a class="el" href="group__stfgen.html#ggae703f7802498ae301ac058b94426900fa64735633245afb7ddbbecf5a49ea00ba">stf::son</a>, 
<a class="el" href="group__stfgen.html#ggae703f7802498ae301ac058b94426900faf4bec932069c6c6f363fbf4a9a2b4312">stf::hdf5</a>, 
<br/>
&#160;&#160;<a class="el" href="group__stfgen.html#ggae703f7802498ae301ac058b94426900fa4172e0376fc3d0059ea45e291d57b37c">stf::heka</a>, 
<a class="el" href="group__stfgen.html#ggae703f7802498ae301ac058b94426900fa8434e1cbb32b170c5df740e0f0305edd">stf::none</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>File types. </p>
 <a href="group__stfgen.html#gae703f7802498ae301ac058b94426900f">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga2fcd50c88877838de7ed4b52e1fedb59">stf::spectrum</a> (const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;data, long K, double &amp;f_n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a spectral estimate using Welch's method.  <a href="#ga2fcd50c88877838de7ed4b52e1fedb59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gacdf87f88e8ac06ad60a3f3b206b0cd91">stf::window</a> (double n, double N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Window function for psd estimation.  <a href="#gacdf87f88e8ac06ad60a3f3b206b0cd91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga62f78deb330cc40d8ae6da48cdbec951">stf::SQR</a> (T a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the square of a number.  <a href="#ga62f78deb330cc40d8ae6da48cdbec951"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga8d4bf7a86a487551837817a7d6d09cf1">stf::filter</a> (const Vector_double &amp;toFilter, std::size_t filter_start, std::size_t filter_end, const Vector_double &amp;a, int SR, Func func, bool inverse=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolutes a data set with a filter function.  <a href="#ga8d4bf7a86a487551837817a7d6d09cf1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gad6d6bf4577ec605215a4a374a3505a03">stf::cubicSpline</a> (const std::vector&lt; T &gt; &amp;y, T oldF, T newF)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates a dataset using cubic splines.  <a href="#gad6d6bf4577ec605215a4a374a3505a03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwxString.html">wxString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga9536c899dc7a569c55ba8957aec43613">stf::sectionToString</a> (const <a class="el" href="classSection.html">Section</a> &amp;section)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classSection.html" title="Represents a continuously sampled sweep of data points.">Section</a> to a <a class="el" href="classwxString.html" title="See http://www.wxwidgets.org/manuals/stable/wx_wxstring.html (wxWidgets documentation)">wxString</a>.  <a href="#ga9536c899dc7a569c55ba8957aec43613"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3892c35dfb30e27bdc9f6e178ebf064e"></a><!-- doxytag: member="stfgen::diff" ref="ga3892c35dfb30e27bdc9f6e178ebf064e" args="(const std::vector&lt; T &gt; &amp;input, T x_scale)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga3892c35dfb30e27bdc9f6e178ebf064e">stf::diff</a> (const std::vector&lt; T &gt; &amp;input, T x_scale)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Differentiate data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga278bc04e06ac5796e0867b158ae4797b">stf::integrate_simpson</a> (const Vector_double &amp;input, std::size_t a, std::size_t b, double x_scale)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration using Simpson's rule.  <a href="#ga278bc04e06ac5796e0867b158ae4797b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga0be2d046407da1c77424a79fa01924ab">stf::integrate_trapezium</a> (const Vector_double &amp;input, std::size_t a, std::size_t b, double x_scale)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration using the trapezium rule.  <a href="#ga0be2d046407da1c77424a79fa01924ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga2e6063c1fcb15672fb84c44065e32455">stf::linsolv</a> (int m, int n, int nrhs, Vector_double &amp;A, Vector_double &amp;B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a linear equation system using LAPACK.  <a href="#ga2e6063c1fcb15672fb84c44065e32455"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gaaaca81c58d327e730c0e785e578ec24e">stf::detectionCriterion</a> (const Vector_double &amp;data, const Vector_double &amp;templ)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the event detection criterion according to Clements &amp; Bekkers (1997).  <a href="#gaaaca81c58d327e730c0e785e578ec24e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga211ecf55c013f280fd1a87d9b762f79e">stf::peakIndices</a> (const Vector_double &amp;data, double threshold, int minDistance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for positive-going peaks.  <a href="#ga211ecf55c013f280fd1a87d9b762f79e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gaa0386bf9c9ceb5499900af490e06e2ab">stf::linCorr</a> (const Vector_double &amp;va1, const Vector_double &amp;va2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear correlation between two arrays.  <a href="#gaa0386bf9c9ceb5499900af490e06e2ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gaa947b273fe10b4e93fdcba6865815a07">stf::fgauss</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of an arbitrary number of Gaussians.  <a href="#gaa947b273fe10b4e93fdcba6865815a07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gaf3e890196c425798f9d97ef3b4846837">stf::fgaussColqu</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a Gaussian that can be used as a filter kernel.  <a href="#gaf3e890196c425798f9d97ef3b4846837"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga1f97545508d6e155d20c896e5ce21f4d">stf::fboltz</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a Boltzmann function.  <a href="#ga1f97545508d6e155d20c896e5ce21f4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gacb01a426bb2ab315da605e22cf1b176d">stf::fbessel</a> (double x, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a Bessel polynomial.  <a href="#gacb01a426bb2ab315da605e22cf1b176d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gae0c21c43d67f957c3224d454319a7c00">stf::fbessel4</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 4th-order Bessel polynomial that can be used as a filter kernel.  <a href="#gae0c21c43d67f957c3224d454319a7c00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwxString.html">wxString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga32ad0c8e262d2985d84451d3f2c52028">stf::CreatePreview</a> (const <a class="el" href="classwxString.html">wxString</a> &amp;fName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a preview of a text file.  <a href="#ga32ad0c8e262d2985d84451d3f2c52028"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gaf31edaa97d0a41cd830c9478e04fd375">stf::fac</a> (int arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the faculty of an integer.  <a href="#gaf31edaa97d0a41cd830c9478e04fd375"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gac8474c28c6c1e5cce375823a1d38591d">stf::pow2</a> (int arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$ 2^{arg} $" src="form_6.png"/>. Uses the bitwise-shift operator (&lt;&lt;).  <a href="#gac8474c28c6c1e5cce375823a1d38591d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwxString.html">wxString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gad14c86e14d611fd5c11eca4edfbb4fb8">stf::noPath</a> (const <a class="el" href="classwxString.html">wxString</a> &amp;fName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the directory off a full path name, returns only the filename.  <a href="#gad14c86e14d611fd5c11eca4edfbb4fb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__stfgen.html#gae703f7802498ae301ac058b94426900f">stf::filetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga60f83eec1f06c30440d1f576bd5a5f7e">stf::findType</a> (const <a class="el" href="classwxString.html">wxString</a> &amp;ext)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to determine the filetype from the filter extension.  <a href="#ga60f83eec1f06c30440d1f576bd5a5f7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga3c37983f5e22f103c26a77b09d8206ad">stf::importFile</a> (const <a class="el" href="classwxString.html">wxString</a> &amp;fName, <a class="el" href="group__stfgen.html#gae703f7802498ae301ac058b94426900f">stf::filetype</a> type, <a class="el" href="classRecording.html">Recording</a> &amp;ReturnData, const <a class="el" href="structstf_1_1txtImportSettings.html">stf::txtImportSettings</a> &amp;txtImport, bool progress=true, <a class="el" href="classwxWindow.html">wxWindow</a> *parent=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic file import.  <a href="#ga3c37983f5e22f103c26a77b09d8206ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga502a391afc11e955c34aa4a6efc208af">stf::exportFile</a> (const <a class="el" href="classwxString.html">wxString</a> &amp;fName, <a class="el" href="group__stfgen.html#gae703f7802498ae301ac058b94426900f">stf::filetype</a> type, const <a class="el" href="classRecording.html">Recording</a> &amp;Data, bool progress=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic file export.  <a href="#ga502a391afc11e955c34aa4a6efc208af"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga29e77fd36f4c103444287e9c5b807ab9">stf::linFit</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y, T &amp;m, T &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a linear fit.  <a href="#ga29e77fd36f4c103444287e9c5b807ab9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double StfDll&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gacf43d0ea16185a30745919255f231c80">stf::lmFit</a> (const Vector_double &amp;data, double dt, const <a class="el" href="structstf_1_1storedFunc.html">stf::storedFunc</a> &amp;fitFunc, const Vector_double &amp;opts, bool use_scaling, Vector_double &amp;p, <a class="el" href="classwxString.html">wxString</a> &amp;info, int &amp;warning)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the Levenberg-Marquardt algorithm to perform a non-linear least-squares fit.  <a href="#gacf43d0ea16185a30745919255f231c80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga96ce124f20c81dcdac988e31770b65c5">stf::flin</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear function.  <a href="#ga96ce124f20c81dcdac988e31770b65c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf47eaaf817ab9f675c36f1b77811fd9"></a><!-- doxytag: member="stfgen::flin_init" ref="gacf47eaaf817ab9f675c36f1b77811fd9" args="(const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gacf47eaaf817ab9f675c36f1b77811fd9">stf::flin_init</a> (const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy function to be passed to <a class="el" href="structstf_1_1storedFunc.html" title="Function used for least-squares fitting.">stf::storedFunc</a> for linear functions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstf_1_1storedFunc.html">stf::storedFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gacce99eda0b9fa51555b8b8adbfef7700">stf::initLinFunc</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes a linear function  <a href="#gacce99eda0b9fa51555b8b8adbfef7700"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga89d5f83830be9b0132ddb34c5d46d281">stf::get_scale</a> (Vector_double &amp;data, double oldx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and perform normalisation.  <a href="#ga89d5f83830be9b0132ddb34c5d46d281"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga365e8fdc4f5836f495e6f1dd95baf3fa">stf::base</a> (double &amp;var, const std::vector&lt; double &gt; &amp;data, std::size_t llb, std::size_t ulb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the average of all sampling points between and including <em>llb</em> and <em>ulb</em>.  <a href="#ga365e8fdc4f5836f495e6f1dd95baf3fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga0f30710d3729c00c31a1aa82d08badff">stf::peak</a> (const std::vector&lt; double &gt; &amp;data, double base, std::size_t llp, std::size_t ulp, int pM, <a class="el" href="group__stfgen.html#gae8845ae2aeaf4b742a905a2a5571fd5a">stf::direction</a>, double &amp;maxT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the peak value of <em>data</em> between <em>llp</em> and <em>ulp</em>.  <a href="#ga0f30710d3729c00c31a1aa82d08badff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gaafcb097f10d8179f38881321d7cd86f3">stf::threshold</a> (const std::vector&lt; double &gt; &amp;data, std::size_t llp, std::size_t ulp, double slope, double &amp;thrT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the value within <em>data</em> between <em>llp</em> and <em>ulp</em> at which <em>slope</em> is exceeded.  <a href="#gaafcb097f10d8179f38881321d7cd86f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gada6c5911cfc604b337b76d1198d8cd37">stf::risetime</a> (const std::vector&lt; double &gt; &amp;data, double base, double ampl, double left, double right, std::size_t &amp;t20Id, std::size_t &amp;t80Id, double &amp;t20Real)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find 20 to 80% rise time of an event in <em>data</em>.  <a href="#gada6c5911cfc604b337b76d1198d8cd37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga7c43d9ceb4e7ce199c0278b52e28386d">stf::t_half</a> (const std::vector&lt; double &gt; &amp;data, double base, double ampl, double left, double right, double center, std::size_t &amp;t50LeftId, std::size_t &amp;t50RightId, double &amp;t50LeftReal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the full width at half-maximal amplitude of an event within <em>data</em>.  <a href="#ga7c43d9ceb4e7ce199c0278b52e28386d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga3fe029fabcdd9669244b896cd57fede3">stf::maxRise</a> (const std::vector&lt; double &gt; &amp;data, double left, double right, double &amp;maxRiseT, double &amp;maxRiseY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal slope during the rising phase of an event within <em>data</em>.  <a href="#ga3fe029fabcdd9669244b896cd57fede3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga7aea0ee12af70b3eb64016585df82eeb">stf::maxDecay</a> (const std::vector&lt; double &gt; &amp;data, double left, double right, double &amp;maxDecayT, double &amp;maxDecayY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximal slope during the decaying phase of an event within <em>data</em>.  <a href="#ga7aea0ee12af70b3eb64016585df82eeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8fefeddc3e296792aeb1c4169bcf6992"></a><!-- doxytag: member="stfgen::vec_scal_plus" ref="ga8fefeddc3e296792aeb1c4169bcf6992" args="(const Vector_double &amp;vec, double scalar)" -->
Vector_double&#160;</td><td class="memItemRight" valign="bottom"><b>stf::vec_scal_plus</b> (const Vector_double &amp;vec, double scalar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga635ebb6f8676ca855fe93b83028efafc"></a><!-- doxytag: member="stfgen::vec_scal_minus" ref="ga635ebb6f8676ca855fe93b83028efafc" args="(const Vector_double &amp;vec, double scalar)" -->
Vector_double&#160;</td><td class="memItemRight" valign="bottom"><b>stf::vec_scal_minus</b> (const Vector_double &amp;vec, double scalar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d3019104e48837b3e73441bf3c114f8"></a><!-- doxytag: member="stfgen::vec_scal_mul" ref="ga1d3019104e48837b3e73441bf3c114f8" args="(const Vector_double &amp;vec, double scalar)" -->
Vector_double&#160;</td><td class="memItemRight" valign="bottom"><b>stf::vec_scal_mul</b> (const Vector_double &amp;vec, double scalar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2b8a0bf817a5cae1752bd5f5adb1b6bc"></a><!-- doxytag: member="stfgen::vec_scal_div" ref="ga2b8a0bf817a5cae1752bd5f5adb1b6bc" args="(const Vector_double &amp;vec, double scalar)" -->
Vector_double&#160;</td><td class="memItemRight" valign="bottom"><b>stf::vec_scal_div</b> (const Vector_double &amp;vec, double scalar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga51d7332f01697cfc06f2bd5b52c52f15"></a><!-- doxytag: member="stfgen::vec_vec_plus" ref="ga51d7332f01697cfc06f2bd5b52c52f15" args="(const Vector_double &amp;vec1, const Vector_double &amp;vec2)" -->
Vector_double&#160;</td><td class="memItemRight" valign="bottom"><b>stf::vec_vec_plus</b> (const Vector_double &amp;vec1, const Vector_double &amp;vec2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9c715d4f5927507dc34eaeeea0840968"></a><!-- doxytag: member="stfgen::vec_vec_minus" ref="ga9c715d4f5927507dc34eaeeea0840968" args="(const Vector_double &amp;vec1, const Vector_double &amp;vec2)" -->
Vector_double&#160;</td><td class="memItemRight" valign="bottom"><b>stf::vec_vec_minus</b> (const Vector_double &amp;vec1, const Vector_double &amp;vec2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ee73a2a48f6d19a94e77fe33d8fd664"></a><!-- doxytag: member="stfgen::vec_vec_mul" ref="ga1ee73a2a48f6d19a94e77fe33d8fd664" args="(const Vector_double &amp;vec1, const Vector_double &amp;vec2)" -->
Vector_double&#160;</td><td class="memItemRight" valign="bottom"><b>stf::vec_vec_mul</b> (const Vector_double &amp;vec1, const Vector_double &amp;vec2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa34bbc6c34b76d8f2d7ec80f6afc9164"></a><!-- doxytag: member="stfgen::vec_vec_div" ref="gaa34bbc6c34b76d8f2d7ec80f6afc9164" args="(const Vector_double &amp;vec1, const Vector_double &amp;vec2)" -->
Vector_double&#160;</td><td class="memItemRight" valign="bottom"><b>stf::vec_vec_div</b> (const Vector_double &amp;vec1, const Vector_double &amp;vec2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0dd74b65e47d94acfc41705c9c4dd872"></a><!-- doxytag: member="stfgen::nojac" ref="ga0dd74b65e47d94acfc41705c9c4dd872" args="(double x, const Vector_double &amp;p)" -->
Vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga0dd74b65e47d94acfc41705c9c4dd872">stf::nojac</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy function, serves as a placeholder to initialize functions without a Jacobian. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafdb0668b03431e76286bbf94363d70bc"></a><!-- doxytag: member="stfgen::noscale" ref="gafdb0668b03431e76286bbf94363d70bc" args="(double param, double xscale, double xoff, double yscale, double yoff)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gafdb0668b03431e76286bbf94363d70bc">stf::noscale</a> (double param, double xscale, double xoff, double yscale, double yoff)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy function, serves as a placeholder to initialize parameters without a scaling function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacb88ca09147b65f75b9347d0d2462cef"></a><!-- doxytag: member="stfgen::defaultOutput" ref="gacb88ca09147b65f75b9347d0d2462cef" args="(const Vector_double &amp;pars, const std::vector&lt; parInfo &gt; &amp;parsInfo, double chisqr)" -->
Table&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gacb88ca09147b65f75b9347d0d2462cef">stf::defaultOutput</a> (const Vector_double &amp;pars, const std::vector&lt; parInfo &gt; &amp;parsInfo, double chisqr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default fit output function, constructing a <a class="el" href="classstf_1_1Table.html" title="A table used for printing information.">stf::Table</a> from the parameters, their description and chisqr. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga555e6d942a4dc2437482dbe9c5fed9ab">stf::round</a> (double toRound)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does what it says.  <a href="#ga555e6d942a4dc2437482dbe9c5fed9ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gaa7e2a13c3f81aa07434ab6ba4da4a617">stf::fexp</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of <em>n</em> exponential functions.  <a href="#gaa7e2a13c3f81aa07434ab6ba4da4a617"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga17dd9dd4ebcdfd99370cc21505dbca94">stf::fexp_jac</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian of stf::fexp().  <a href="#ga17dd9dd4ebcdfd99370cc21505dbca94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga205a9760c992ccc914c114dcdf72eacb">stf::fexp_init</a> (const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises parameters for fitting stf::fexp() to <em>data</em>.  <a href="#ga205a9760c992ccc914c114dcdf72eacb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga52d567f013f039416a245b985af83bbf">stf::fexp_init2</a> (const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Yet another initialiser for fitting stf::fexp() to <em>data</em>.  <a href="#ga52d567f013f039416a245b985af83bbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga214dc6bb2e3a2ad37ab9e4650b55c632">stf::fexpde</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Monoexponential function with delay.  <a href="#ga214dc6bb2e3a2ad37ab9e4650b55c632"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga4c3336556c6aa992cf19e1b2e4ec7a76">stf::fexpde_init</a> (const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises parameters for fitting stf::fexpde() to <em>data</em>.  <a href="#ga4c3336556c6aa992cf19e1b2e4ec7a76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga4dd9d335d263c75d61961db8bb1fe1e2">stf::fexpbde</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Biexponential function with delay.  <a href="#ga4dd9d335d263c75d61961db8bb1fe1e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gaf0561e7b630cce2263693f8e86167eea">stf::fexpbde_init</a> (const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises parameters for fitting stf::fexpde() to <em>data</em>.  <a href="#gaf0561e7b630cce2263693f8e86167eea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gafa6594e79d6dd700e3dfc91528f5be56">stf::falpha</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alpha function.  <a href="#gafa6594e79d6dd700e3dfc91528f5be56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga8b22dedbea54a0994d9b41d5c03d0459">stf::falpha_jac</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian of stf::falpha().  <a href="#ga8b22dedbea54a0994d9b41d5c03d0459"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga63447f9728c486a97b390102ff325018">stf::fHH</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hodgkin-Huxley sodium conductance function.  <a href="#ga63447f9728c486a97b390102ff325018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga6c64c923dcb8f39d644163ab0c09abbe">stf::fgnabiexp</a> (double x, const Vector_double &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">power of 1 sodium conductance function.  <a href="#ga6c64c923dcb8f39d644163ab0c09abbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga47d38cf93cda965b8dc517cf5fa20ac1">stf::falpha_init</a> (const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises parameters for fitting stf::falpha() to <em>data</em>.  <a href="#ga47d38cf93cda965b8dc517cf5fa20ac1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gacaee0bf94446342456475acd827bb1f1">stf::fHH_init</a> (const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises parameters for fitting stf::falpha() to <em>data</em>.  <a href="#gacaee0bf94446342456475acd827bb1f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga5454dcb2feefac399c4f5e9d7a277dd7">stf::fgnabiexp_init</a> (const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises parameters for fitting stf::falpha() to <em>data</em>.  <a href="#ga5454dcb2feefac399c4f5e9d7a277dd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gabe31dea1c4b9c10627815f17c56f4549">stf::xscale</a> (double param, double xscale, double xoff, double yscale, double yoff)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a parameter that linearly depends on x.  <a href="#gabe31dea1c4b9c10627815f17c56f4549"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga3f08b8e36843ae1e5ef9b285cc5f86b7">stf::xunscale</a> (double param, double xscale, double xoff, double yscale, double yoff)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unscales a parameter that linearly depends on x.  <a href="#ga3f08b8e36843ae1e5ef9b285cc5f86b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga00c92887edc6d459207573419ede56ef">stf::yscale</a> (double param, double xscale, double xoff, double yscale, double yoff)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a parameter that linearly depends on y.  <a href="#ga00c92887edc6d459207573419ede56ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gae9d5e4c6d163781154d54888906e3928">stf::yscaleoffset</a> (double param, double xscale, double xoff, double yscale, double yoff)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a parameter that linearly depends on y and adds an offset.  <a href="#gae9d5e4c6d163781154d54888906e3928"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga7d081bd58e0107dc245a8441e45e3929">stf::yunscale</a> (double param, double xscale, double xoff, double yscale, double yoff)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unscales a parameter that linearly depends on y.  <a href="#ga7d081bd58e0107dc245a8441e45e3929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gab000f4b8bc54c11315091c912ba0c1e0">stf::yunscaleoffset</a> (double param, double xscale, double xoff, double yscale, double yoff)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unscales a parameter that linearly depends on y and removes the offset.  <a href="#gab000f4b8bc54c11315091c912ba0c1e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; parInfo &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#gaa535878b74675e92a48e0e20a7e6b1a6">stf::getParInfoExp</a> (int n_exp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="structstf_1_1parInfo.html" title="Information about parameters used in storedFunc.">stf::parInfo</a> structs for n-exponential functions.  <a href="#gaa535878b74675e92a48e0e20a7e6b1a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstf_1_1Table.html">stf::Table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga62fd233e1b8aaa7e71bcc639793b3c93">stf::outputWTau</a> (const Vector_double &amp;p, const std::vector&lt; parInfo &gt; &amp;parsInfo, double chisqr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a weighted time constant.  <a href="#ga62fd233e1b8aaa7e71bcc639793b3c93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga7fa85af19cf73937c166e0fa1aad7955">stf::whereis</a> (const Vector_double &amp;data, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of <em>data</em> where <em>value</em> is encountered for the first time.  <a href="#ga7fa85af19cf73937c166e0fa1aad7955"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstf_1_1storedFunc.html">stf::storedFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga14b43f4510558137aac70408cd1c036b">stf::GetFuncLib</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the library of functions for non-linear regression.  <a href="#ga14b43f4510558137aac70408cd1c036b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b9c4776a431231a9db345759e7de8ae"></a><!-- doxytag: member="stfgen::PI" ref="ga5b9c4776a431231a9db345759e7de8ae" args="" -->
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stfgen.html#ga5b9c4776a431231a9db345759e7de8ae">stf::PI</a> = 3.14159265358979323846</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add decimals if you are not satisfied. <br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga11d6ec55abceacf5fdd47f9fc889d9a3"></a><!-- doxytag: member="stf::Func" ref="ga11d6ec55abceacf5fdd47f9fc889d9a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;double(double, const Vector_double&amp;)&gt; <a class="el" href="group__stfgen.html#ga11d6ec55abceacf5fdd47f9fc889d9a3">stf::Func</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function taking a double and a vector and returning a double. </p>
<p>Type definition for a function (or, to be precise, any 'callable entity') that takes a double (the x-value) and a vector of parameters and returns the function's result (the y-value). </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gad2d1acb3ac0c16ee32b5f4d3a1ab4abf"></a><!-- doxytag: member="stf::cursor_type" ref="gad2d1acb3ac0c16ee32b5f4d3a1ab4abf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stfgen.html#gad2d1acb3ac0c16ee32b5f4d3a1ab4abf">stf::cursor_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mouse cursor types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa1b879af00b1b8b8c4a195c0b27de3f0b"></a><!-- doxytag: member="measure_cursor" ref="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa1b879af00b1b8b8c4a195c0b27de3f0b" args="" -->measure_cursor</em>&nbsp;</td><td>
<p>Measurement cursor (crosshair). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfad99eafbc283ce642e9ff607357c95e9b"></a><!-- doxytag: member="peak_cursor" ref="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfad99eafbc283ce642e9ff607357c95e9b" args="" -->peak_cursor</em>&nbsp;</td><td>
<p>Peak calculation limits cursor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa8c54633348bfe4fdeaf6c8ddf06fccba"></a><!-- doxytag: member="base_cursor" ref="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa8c54633348bfe4fdeaf6c8ddf06fccba" args="" -->base_cursor</em>&nbsp;</td><td>
<p>Baseline calculation limits cursor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfab09f70483c5bed40addf3c21eb528afe"></a><!-- doxytag: member="decay_cursor" ref="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfab09f70483c5bed40addf3c21eb528afe" args="" -->decay_cursor</em>&nbsp;</td><td>
<p>Fit limits cursor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfabb059a629fb7fbf5d9a3f83c44954b9b"></a><!-- doxytag: member="latency_cursor" ref="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfabb059a629fb7fbf5d9a3f83c44954b9b" args="" -->latency_cursor</em>&nbsp;</td><td>
<p>Latency cursor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfadb6eff6e3108c48f2dd357dc3b539238"></a><!-- doxytag: member="zoom_cursor" ref="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfadb6eff6e3108c48f2dd357dc3b539238" args="" -->zoom_cursor</em>&nbsp;</td><td>
<p>Zoom rectangle cursor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa28885ead48beb5a6da1810d391d41760"></a><!-- doxytag: member="event_cursor" ref="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa28885ead48beb5a6da1810d391d41760" args="" -->event_cursor</em>&nbsp;</td><td>
<p><a class="el" href="classstf_1_1Event.html" title="Describes the attributes of an event.">Event</a> mode cursor. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa2794c8863a730fbd8e4dea7f93b8dfa7"></a><!-- doxytag: member="undefined_cursor" ref="ggad2d1acb3ac0c16ee32b5f4d3a1ab4abfa2794c8863a730fbd8e4dea7f93b8dfa7" args="" -->undefined_cursor</em>&nbsp;</td><td>
<p>Undefined cursor. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gae8845ae2aeaf4b742a905a2a5571fd5a"></a><!-- doxytag: member="stf::direction" ref="gae8845ae2aeaf4b742a905a2a5571fd5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stfgen.html#gae8845ae2aeaf4b742a905a2a5571fd5a">stf::direction</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The direction of peak calculations. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae8845ae2aeaf4b742a905a2a5571fd5aaf12a3d86708046ee92fa400c99fcbecb"></a><!-- doxytag: member="up" ref="ggae8845ae2aeaf4b742a905a2a5571fd5aaf12a3d86708046ee92fa400c99fcbecb" args="" -->up</em>&nbsp;</td><td>
<p>Find positive-going peaks. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae8845ae2aeaf4b742a905a2a5571fd5aaccaa84903131c15d67e4f95298e68e2b"></a><!-- doxytag: member="down" ref="ggae8845ae2aeaf4b742a905a2a5571fd5aaccaa84903131c15d67e4f95298e68e2b" args="" -->down</em>&nbsp;</td><td>
<p>Find negative-going peaks. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae8845ae2aeaf4b742a905a2a5571fd5aa22cccef6520f7679886dc6d584805ce3"></a><!-- doxytag: member="both" ref="ggae8845ae2aeaf4b742a905a2a5571fd5aa22cccef6520f7679886dc6d584805ce3" args="" -->both</em>&nbsp;</td><td>
<p>Find negative- or positive-going peaks, whichever is larger. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae8845ae2aeaf4b742a905a2a5571fd5aab5df1157da4f45612d5815bc164e0931"></a><!-- doxytag: member="undefined_direction" ref="ggae8845ae2aeaf4b742a905a2a5571fd5aab5df1157da4f45612d5815bc164e0931" args="" -->undefined_direction</em>&nbsp;</td><td>
<p>Undefined direction. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gae703f7802498ae301ac058b94426900f"></a><!-- doxytag: member="stf::filetype" ref="gae703f7802498ae301ac058b94426900f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stfgen.html#gae703f7802498ae301ac058b94426900f">stf::filetype</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>File types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae703f7802498ae301ac058b94426900fa0136c00f38aa0ad185d30d7c845f38b5"></a><!-- doxytag: member="atf" ref="ggae703f7802498ae301ac058b94426900fa0136c00f38aa0ad185d30d7c845f38b5" args="" -->atf</em>&nbsp;</td><td>
<p>Axon text file. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae703f7802498ae301ac058b94426900fa5496504b8584246c4ee5820087f94be2"></a><!-- doxytag: member="abf" ref="ggae703f7802498ae301ac058b94426900fa5496504b8584246c4ee5820087f94be2" args="" -->abf</em>&nbsp;</td><td>
<p>Axon binary file. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae703f7802498ae301ac058b94426900fa8140bedc5caf41a80dbbdb1bed69b799"></a><!-- doxytag: member="axg" ref="ggae703f7802498ae301ac058b94426900fa8140bedc5caf41a80dbbdb1bed69b799" args="" -->axg</em>&nbsp;</td><td>
<p>Axograph binary file. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae703f7802498ae301ac058b94426900fa653f7b20462a96d94629bf0a997f70f9"></a><!-- doxytag: member="ascii" ref="ggae703f7802498ae301ac058b94426900fa653f7b20462a96d94629bf0a997f70f9" args="" -->ascii</em>&nbsp;</td><td>
<p>Generic text file. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae703f7802498ae301ac058b94426900fa0eb892b5486c4452d4030cd8a6788457"></a><!-- doxytag: member="cfs" ref="ggae703f7802498ae301ac058b94426900fa0eb892b5486c4452d4030cd8a6788457" args="" -->cfs</em>&nbsp;</td><td>
<p>CED filing system. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae703f7802498ae301ac058b94426900fa8b7b106321d7c7cad7791629bb4e11f9"></a><!-- doxytag: member="igor" ref="ggae703f7802498ae301ac058b94426900fa8b7b106321d7c7cad7791629bb4e11f9" args="" -->igor</em>&nbsp;</td><td>
<p>Igor binary wave. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae703f7802498ae301ac058b94426900fa64735633245afb7ddbbecf5a49ea00ba"></a><!-- doxytag: member="son" ref="ggae703f7802498ae301ac058b94426900fa64735633245afb7ddbbecf5a49ea00ba" args="" -->son</em>&nbsp;</td><td>
<p>CED Son files. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae703f7802498ae301ac058b94426900faf4bec932069c6c6f363fbf4a9a2b4312"></a><!-- doxytag: member="hdf5" ref="ggae703f7802498ae301ac058b94426900faf4bec932069c6c6f363fbf4a9a2b4312" args="" -->hdf5</em>&nbsp;</td><td>
<p>hdf5 files. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae703f7802498ae301ac058b94426900fa4172e0376fc3d0059ea45e291d57b37c"></a><!-- doxytag: member="heka" ref="ggae703f7802498ae301ac058b94426900fa4172e0376fc3d0059ea45e291d57b37c" args="" -->heka</em>&nbsp;</td><td>
<p>heka files. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae703f7802498ae301ac058b94426900fa8434e1cbb32b170c5df740e0f0305edd"></a><!-- doxytag: member="none" ref="ggae703f7802498ae301ac058b94426900fa8434e1cbb32b170c5df740e0f0305edd" args="" -->none</em>&nbsp;</td><td>
<p>Undefined file type. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga738f9934a45a9d2d81cb0a3de0375c99"></a><!-- doxytag: member="stf::latency_mode" ref="ga738f9934a45a9d2d81cb0a3de0375c99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stfgen.html#ga738f9934a45a9d2d81cb0a3de0375c99">stf::latency_mode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Latency cursor settings. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga738f9934a45a9d2d81cb0a3de0375c99a38b8edc5f8a706c23b6efd737aada25a"></a><!-- doxytag: member="manualMode" ref="gga738f9934a45a9d2d81cb0a3de0375c99a38b8edc5f8a706c23b6efd737aada25a" args="" -->manualMode</em>&nbsp;</td><td>
<p>Set the corresponding latency cursor manually (by clicking on the graph). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga738f9934a45a9d2d81cb0a3de0375c99a42837a2123b13815fb4ee3c005f2cac0"></a><!-- doxytag: member="peakMode" ref="gga738f9934a45a9d2d81cb0a3de0375c99a42837a2123b13815fb4ee3c005f2cac0" args="" -->peakMode</em>&nbsp;</td><td>
<p>Set the corresponding latency cursor to the peak. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga738f9934a45a9d2d81cb0a3de0375c99abbb23ece92fe176e5358289e2b14f97e"></a><!-- doxytag: member="riseMode" ref="gga738f9934a45a9d2d81cb0a3de0375c99abbb23ece92fe176e5358289e2b14f97e" args="" -->riseMode</em>&nbsp;</td><td>
<p>Set the corresponding latency cursor to the maximal slope of rise. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga738f9934a45a9d2d81cb0a3de0375c99ae23bd76db1d3f2fd5ee275c5dc004283"></a><!-- doxytag: member="halfMode" ref="gga738f9934a45a9d2d81cb0a3de0375c99ae23bd76db1d3f2fd5ee275c5dc004283" args="" -->halfMode</em>&nbsp;</td><td>
<p>Set the corresponding latency cursor to the half-maximal amplitude. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga738f9934a45a9d2d81cb0a3de0375c99a216dce55e173d3838de785cf0a42d87e"></a><!-- doxytag: member="footMode" ref="gga738f9934a45a9d2d81cb0a3de0375c99a216dce55e173d3838de785cf0a42d87e" args="" -->footMode</em>&nbsp;</td><td>
<p>Set the corresponding latency cursor to the beginning of an event. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga738f9934a45a9d2d81cb0a3de0375c99a871047aafad5c561dbf5a77e80a7b174"></a><!-- doxytag: member="undefinedMode" ref="gga738f9934a45a9d2d81cb0a3de0375c99a871047aafad5c561dbf5a77e80a7b174" args="" -->undefinedMode</em>&nbsp;</td><td>
<p>undefined mode. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gae034ed0eec6bdaba3b23d3b2184f799d"></a><!-- doxytag: member="stf::latency_window_mode" ref="gae034ed0eec6bdaba3b23d3b2184f799d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stfgen.html#gae034ed0eec6bdaba3b23d3b2184f799d">stf::latency_window_mode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Latency window settings. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae034ed0eec6bdaba3b23d3b2184f799da65ce55297aad4c581e70b239864c2a16"></a><!-- doxytag: member="defaultMode" ref="ggae034ed0eec6bdaba3b23d3b2184f799da65ce55297aad4c581e70b239864c2a16" args="" -->defaultMode</em>&nbsp;</td><td>
<p>Use the current peak cursor window for the active channel. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae034ed0eec6bdaba3b23d3b2184f799daf28fa2b9cdf5e498f1ed689e1d8d1934"></a><!-- doxytag: member="windowMode" ref="ggae034ed0eec6bdaba3b23d3b2184f799daf28fa2b9cdf5e498f1ed689e1d8d1934" args="" -->windowMode</em>&nbsp;</td><td>
<p>Use a window of 100 sampling points around the peak. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9a792b11c01e9429bfe2acd3e4ef108b"></a><!-- doxytag: member="stf::zoom_channels" ref="ga9a792b11c01e9429bfe2acd3e4ef108b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stfgen.html#ga9a792b11c01e9429bfe2acd3e4ef108b">stf::zoom_channels</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines which channels to scale. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga9a792b11c01e9429bfe2acd3e4ef108bafdaacd56a89cce6998f8fcc331b0f665"></a><!-- doxytag: member="zoomch1" ref="gga9a792b11c01e9429bfe2acd3e4ef108bafdaacd56a89cce6998f8fcc331b0f665" args="" -->zoomch1</em>&nbsp;</td><td>
<p>Scaling applies to channel 1 only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9a792b11c01e9429bfe2acd3e4ef108baef0062d1da678e4771bf559b3dc1e537"></a><!-- doxytag: member="zoomch2" ref="gga9a792b11c01e9429bfe2acd3e4ef108baef0062d1da678e4771bf559b3dc1e537" args="" -->zoomch2</em>&nbsp;</td><td>
<p>Scaling applies to channel 2 only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9a792b11c01e9429bfe2acd3e4ef108ba0c34eab028555c38760abc86b551b6c6"></a><!-- doxytag: member="zoomboth" ref="gga9a792b11c01e9429bfe2acd3e4ef108ba0c34eab028555c38760abc86b551b6c6" args="" -->zoomboth</em>&nbsp;</td><td>
<p>Scaling applies to both channels. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga365e8fdc4f5836f495e6f1dd95baf3fa"></a><!-- doxytag: member="stf::base" ref="ga365e8fdc4f5836f495e6f1dd95baf3fa" args="(double &amp;var, const std::vector&lt; double &gt; &amp;data, std::size_t llb, std::size_t ulb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::base </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>llb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ulb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the average of all sampling points between and including <em>llb</em> and <em>ulb</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>Will contain the variance on exit. </td></tr>
    <tr><td class="paramname">data</td><td>The data waveform to be analysed. </td></tr>
    <tr><td class="paramname">llb</td><td>Averaging will be started at this index. </td></tr>
    <tr><td class="paramname">ulb</td><td>Index of the last data point included in the average (legacy of the PASCAL version). </td></tr>
    <tr><td class="paramname">llp</td><td>Lower limit of the peak window (see stf::peak()). </td></tr>
    <tr><td class="paramname">ulp</td><td>Upper limit of the peak window (see stf::peak()). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The baseline value. </dd></dl>

<p>Referenced by <a class="el" href="classRecording.html#a71acc241d3c282fde919c8e710876541">Recording::GetBase()</a>.</p>

</div>
</div>
<a class="anchor" id="ga32ad0c8e262d2985d84451d3f2c52028"></a><!-- doxytag: member="stf::CreatePreview" ref="ga32ad0c8e262d2985d84451d3f2c52028" args="(const wxString &amp;fName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwxString.html">wxString</a> stf::CreatePreview </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwxString.html">wxString</a> &amp;&#160;</td>
          <td class="paramname"><em>fName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a preview of a text file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fName</td><td>Full path name of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string showing at most the initial 100 lines of the text file. </dd></dl>

</div>
</div>
<a class="anchor" id="gad6d6bf4577ec605215a4a374a3505a03"></a><!-- doxytag: member="stf::cubicSpline" ref="gad6d6bf4577ec605215a4a374a3505a03" args="(const std::vector&lt; T &gt; &amp;y, T oldF, T newF)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; stf::cubicSpline </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>oldF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>newF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interpolates a dataset using cubic splines. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The valarray to be interpolated. </td></tr>
    <tr><td class="paramname">oldF</td><td>The original sampling frequency. </td></tr>
    <tr><td class="paramname">newF</td><td>The new frequency of the interpolated array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The interpolated data set. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaaca81c58d327e730c0e785e578ec24e"></a><!-- doxytag: member="stf::detectionCriterion" ref="gaaaca81c58d327e730c0e785e578ec24e" args="(const Vector_double &amp;data, const Vector_double &amp;templ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector_double stf::detectionCriterion </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>templ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the event detection criterion according to Clements &amp; Bekkers (1997). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The valarray from which to extract events. </td></tr>
    <tr><td class="paramname">templ</td><td>A template waveform that is used for event detection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The detection criterion for every value of <em>data</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga502a391afc11e955c34aa4a6efc208af"></a><!-- doxytag: member="stf::exportFile" ref="ga502a391afc11e955c34aa4a6efc208af" args="(const wxString &amp;fName, stf::filetype type, const Recording &amp;Data, bool progress=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::exportFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwxString.html">wxString</a> &amp;&#160;</td>
          <td class="paramname"><em>fName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stfgen.html#gae703f7802498ae301ac058b94426900f">stf::filetype</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRecording.html">Recording</a> &amp;&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>progress</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic file export. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fName</td><td>The full path name of the file. </td></tr>
    <tr><td class="paramname">type</td><td>The file type. </td></tr>
    <tr><td class="paramname">Data</td><td>Data to be written </td></tr>
    <tr><td class="paramname">progress</td><td>Set to true if a progress dialog should be shown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the file has successfully been written, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf31edaa97d0a41cd830c9478e04fd375"></a><!-- doxytag: member="stf::fac" ref="gaf31edaa97d0a41cd830c9478e04fd375" args="(int arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stf::fac </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the faculty of an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Argument of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The faculty of <em>arg</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa6594e79d6dd700e3dfc91528f5be56"></a><!-- doxytag: member="stf::falpha" ref="gafa6594e79d6dd700e3dfc91528f5be56" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::falpha </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Alpha function. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[f(x)=p_0 p_1^2 x \mathrm{e}^{-p_1 x} + p_2\]" src="form_12.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
    <tr><td class="paramname">p</td><td>A valarray of parameters, where <br/>
 <em>p</em>[0] is the amplitude, <br/>
 <em>p</em>[1] is the rate and <br/>
 <em>p</em>[2] is the offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga47d38cf93cda965b8dc517cf5fa20ac1"></a><!-- doxytag: member="stf::falpha_init" ref="ga47d38cf93cda965b8dc517cf5fa20ac1" args="(const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stf::falpha_init </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>peak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>pInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialises parameters for fitting stf::falpha() to <em>data</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The waveform of the data for the fit. </td></tr>
    <tr><td class="paramname">base</td><td>Baseline of <em>data</em>. </td></tr>
    <tr><td class="paramname">peak</td><td>Peak value of <em>data</em>. </td></tr>
    <tr><td class="paramname">dt</td><td>The sampling interval. </td></tr>
    <tr><td class="paramname">pInit</td><td>On entry, pass a valarray of size 3. On exit, will contain initial parameter estimates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8b22dedbea54a0994d9b41d5c03d0459"></a><!-- doxytag: member="stf::falpha_jac" ref="ga8b22dedbea54a0994d9b41d5c03d0459" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector_double stf::falpha_jac </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the Jacobian of stf::falpha(). </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} j_0(x) &amp;=&amp; \frac{df(x)}{dp_0} = p_1^2 x \mathrm{e}^{-p_1 x} \\ j_1(x) &amp;=&amp; \frac{df(x)}{dp_1} = p_0 p_1 x \left( 2 \mathrm{e}^{-p_1 x} - p_1 x \mathrm{e}^{-p_1 x} \right) \\ j_2(x) &amp;=&amp; \frac{df(x)}{dp_2} = 1.0 \end{eqnarray*}" src="form_13.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
    <tr><td class="paramname">p</td><td>A valarray of parameters, where <br/>
 <em>p</em>[0] is the amplitude, <br/>
 <em>p</em>[1] is the rate and <br/>
 <em>p</em>[2] is the offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valarray <em>j</em> with the evaluated Jacobian, where <br/>
 <em>j</em>[0] contains the derivative with respect to <em>p</em>[0], <br/>
 <em>j</em>[1] contains the derivative with respect to <em>p</em>[1] and <br/>
 <em>j</em>[2] contains the derivative with respect to <em>p</em>[2]. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb01a426bb2ab315da605e22cf1b176d"></a><!-- doxytag: member="stf::fbessel" ref="gacb01a426bb2ab315da605e22cf1b176d" args="(double x, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::fbessel </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a Bessel polynomial. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x, n) = \sum_{k=0}^n \frac{ \left( 2n - k \right) ! }{ \left( n - k \right) ! k! } \frac{x^k}{ 2^{n-k} } \]" src="form_3.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument of the function. </td></tr>
    <tr><td class="paramname">n</td><td>Order of the polynomial. <br/>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0c21c43d67f957c3224d454319a7c00"></a><!-- doxytag: member="stf::fbessel4" ref="gae0c21c43d67f957c3224d454319a7c00" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::fbessel4 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a 4th-order Bessel polynomial that can be used as a filter kernel. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x) = \frac{b(0,4)}{b(\frac{0.355589x}{p_0},4)} \]" src="form_4.png"/>
</p>
<p> where <img class="formulaInl" alt="$ b(a,n) $" src="form_5.png"/> is the bessel polynomial stf::fbessel(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument of the function. </td></tr>
    <tr><td class="paramname">p</td><td>Function parameters, where <br/>
 <em>p</em>[0] is the corner frequency (-3 dB attenuation) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f97545508d6e155d20c896e5ce21f4d"></a><!-- doxytag: member="stf::fboltz" ref="ga1f97545508d6e155d20c896e5ce21f4d" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::fboltz </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a Boltzmann function. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[f(x)=\frac{1}{1+\mathrm{e}^{\frac{p_0-x}{p_1}}}\]" src="form_2.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument of the function. </td></tr>
    <tr><td class="paramname">p</td><td>Function parameters, where <br/>
 <em>p</em>[0] is the midpoint and <br/>
 <em>p</em>[1] is the slope of the function. <br/>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7e2a13c3f81aa07434ab6ba4da4a617"></a><!-- doxytag: member="stf::fexp" ref="gaa7e2a13c3f81aa07434ab6ba4da4a617" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::fexp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sum of <em>n</em> exponential functions. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[f(x)=p_{2n} + \sum_{i=0}^{2 n - 1}p_{2i}\mathrm{e}^{\frac{x}{p_{2i + 1}}}\]" src="form_8.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
    <tr><td class="paramname">p</td><td>A valarray of parameters of size 2<em>n</em>+1, where <br/>
 <em>n</em> is the number of exponential terms, <br/>
 <em>p</em>[2<em>i</em>] is the amplitude term, <br/>
 <em>p</em>[2<em>i</em>+1] is the time constant, <br/>
 <em>p</em>[2<em>n</em>], the last element, contains the offset and <br/>
 <em>i</em> denotes the <em>i</em> -th exponential term (running from 0 to <em>n</em>-1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga205a9760c992ccc914c114dcdf72eacb"></a><!-- doxytag: member="stf::fexp_init" ref="ga205a9760c992ccc914c114dcdf72eacb" args="(const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stf::fexp_init </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>peak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>pInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialises parameters for fitting stf::fexp() to <em>data</em>. </p>
<p>This needs to be made more robust. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The waveform of the data for the fit. </td></tr>
    <tr><td class="paramname">base</td><td>Baseline of <em>data</em>. </td></tr>
    <tr><td class="paramname">peak</td><td>Peak value of <em>data</em>. </td></tr>
    <tr><td class="paramname">dt</td><td>The sampling interval. </td></tr>
    <tr><td class="paramname">pInit</td><td>On entry, pass a valarray of size 2<em>n</em>+1, where <em>n</em> is the number of exponential functions. On exit, will contain initial parameter estimates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52d567f013f039416a245b985af83bbf"></a><!-- doxytag: member="stf::fexp_init2" ref="ga52d567f013f039416a245b985af83bbf" args="(const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stf::fexp_init2 </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>peak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>pInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Yet another initialiser for fitting stf::fexp() to <em>data</em>. </p>
<p>In this case, one of the amplitude terms will have another sign than the others, making it more suitable for fitting PSCs or PSPs. However, this often fails to work in practice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The waveform of the data for the fit. </td></tr>
    <tr><td class="paramname">base</td><td>Baseline of <em>data</em>. </td></tr>
    <tr><td class="paramname">peak</td><td>Peak value of <em>data</em>. </td></tr>
    <tr><td class="paramname">dt</td><td>The sampling interval. </td></tr>
    <tr><td class="paramname">pInit</td><td>On entry, pass a valarray of size 2<em>n</em>+1, where <em>n</em> is the number of exponential functions. On exit, will contain initial parameter estimates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga17dd9dd4ebcdfd99370cc21505dbca94"></a><!-- doxytag: member="stf::fexp_jac" ref="ga17dd9dd4ebcdfd99370cc21505dbca94" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector_double stf::fexp_jac </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the Jacobian of stf::fexp(). </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} j_{2i}(x) &amp;=&amp; \frac{df(x)}{dp_{2i}} = \mathrm{e}^{\frac{-x}{p_{2i+1}}} \\ j_{2i+1}(x) &amp;=&amp; \frac{df(x)}{dp_{2i+1}} = \frac{p_{2i}}{p_{2i+1}^2} x \mathrm{e}^{\frac{-x}{p_{2i+1}}} \\ j_n(x) &amp;=&amp; \frac{df(x)}{dp_{n}} = 1 \end{eqnarray*}" src="form_9.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
    <tr><td class="paramname">p</td><td>A valarray of parameters of size 2<em>n</em>+1, where <br/>
 <em>n</em> is the number of exponential terms, <br/>
 <em>p</em>[2<em>i</em>] is the amplitude term, <br/>
 <em>p</em>[2<em>i</em>+1] is the time constant, <br/>
 <em>p</em>[2<em>n</em>], the last element, contains the offset and <br/>
 <em>i</em> denotes the <em>i</em> -th exponential term (running from 0 to <em>n</em>-1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valarray <em>j</em> of size 2<em>n</em>+1 with the evaluated Jacobian, where <br/>
 <em>j</em>[2<em>i</em>] contains the derivative with respect to <em>p</em>[2<em>i</em>], <br/>
 <em>j</em>[2<em>i</em>+1] contains the derivative with respect to <em>p</em>[2<em>i</em>+1] and <br/>
 <em>j</em>[2<em>n</em>], the last element, contains the derivative with respect to <em>p</em>[2<em>n</em>]. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4dd9d335d263c75d61961db8bb1fe1e2"></a><!-- doxytag: member="stf::fexpbde" ref="ga4dd9d335d263c75d61961db8bb1fe1e2" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::fexpbde </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Biexponential function with delay. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f(x)= \begin{cases} p_0, &amp; \mbox{if }x < p_1 \\ n p_2 \left( \mathrm{e}^{\frac{p_1 - x}{p_2}} - \mathrm{e}^{\frac{p_1 - x}{p_4}} \right) + p_0, &amp; \mbox{if }x \geq p_1 \end{cases} \end{eqnarray*}" src="form_11.png"/>
</p>
<p> <em>n</em> is a normalization factor, <br/>
 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
    <tr><td class="paramname">p</td><td>A valarray of parameters, where <br/>
 <em>p</em>[0] is the baseline, <br/>
 <em>p</em>[1] is the delay. <em>p</em>[2] is the later (slower) time constant, <br/>
 <em>p</em>[3] is the amplitude and <br/>
 <em>p</em>[4] is the earlier (faster) time constant, <br/>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0561e7b630cce2263693f8e86167eea"></a><!-- doxytag: member="stf::fexpbde_init" ref="gaf0561e7b630cce2263693f8e86167eea" args="(const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stf::fexpbde_init </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>peak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>pInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialises parameters for fitting stf::fexpde() to <em>data</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The waveform of the data for the fit. </td></tr>
    <tr><td class="paramname">base</td><td>Baseline of <em>data</em>. </td></tr>
    <tr><td class="paramname">peak</td><td>Peak value of <em>data</em>. </td></tr>
    <tr><td class="paramname">dt</td><td>The sampling interval. </td></tr>
    <tr><td class="paramname">pInit</td><td>On entry, pass a valarray of size 4. On exit, will contain initial parameter estimates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga214dc6bb2e3a2ad37ab9e4650b55c632"></a><!-- doxytag: member="stf::fexpde" ref="ga214dc6bb2e3a2ad37ab9e4650b55c632" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::fexpde </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Monoexponential function with delay. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f(x)= \begin{cases} p_0, &amp; \mbox{if }x < p_3 \\ \left( p_0 - p_2 \right) \mathrm{e}^{\frac{p_3 - x}{p_1}} + p_2, &amp; \mbox{if }x \geq p_3 \end{cases} \end{eqnarray*}" src="form_10.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
    <tr><td class="paramname">p</td><td>A valarray of parameters, where <br/>
 <em>p</em>[0] is the baseline, <br/>
 <em>p</em>[1] is the time constant, <br/>
 <em>p</em>[2] is the amplitude and <br/>
 <em>p</em>[3] is the delay. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c3336556c6aa992cf19e1b2e4ec7a76"></a><!-- doxytag: member="stf::fexpde_init" ref="ga4c3336556c6aa992cf19e1b2e4ec7a76" args="(const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stf::fexpde_init </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>peak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>pInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialises parameters for fitting stf::fexpde() to <em>data</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The waveform of the data for the fit. </td></tr>
    <tr><td class="paramname">base</td><td>Baseline of <em>data</em>. </td></tr>
    <tr><td class="paramname">peak</td><td>Peak value of <em>data</em>. </td></tr>
    <tr><td class="paramname">dt</td><td>The sampling interval. </td></tr>
    <tr><td class="paramname">pInit</td><td>On entry, pass a valarray of size 4. On exit, will contain initial parameter estimates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa947b273fe10b4e93fdcba6865815a07"></a><!-- doxytag: member="stf::fgauss" ref="gaa947b273fe10b4e93fdcba6865815a07" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::fgauss </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the sum of an arbitrary number of Gaussians. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x) = \sum_{i=0}^{n-1}p_{3i}\mathrm{e}^{- \left( \frac{x-p_{3i+1}}{p_{3i+2}} \right) ^2} \]" src="form_0.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument of the function. </td></tr>
    <tr><td class="paramname">p</td><td>A valarray of function parameters of size 3<em>n</em>, where <br/>
 <em>p</em>[3<em>i</em>] is the amplitude of the Gaussian <br/>
 <em>p</em>[3<em>i</em>+1] is the position of the center of the peak, <br/>
 <em>p</em>[3<em>i</em>+2] is the width of the Gaussian, <br/>
 <em>n</em> is the number of Gaussian functions and <br/>
 <em>i</em> is the 0-based index of the i-th Gaussian. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3e890196c425798f9d97ef3b4846837"></a><!-- doxytag: member="stf::fgaussColqu" ref="gaf3e890196c425798f9d97ef3b4846837" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::fgaussColqu </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a Gaussian that can be used as a filter kernel. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(x) = \mathrm{e}^{-0.3466 \left( \frac{x}{p_{0}} \right) ^2} \]" src="form_1.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument of the function. </td></tr>
    <tr><td class="paramname">p</td><td>Function parameters, where <br/>
 <em>p</em>[0] is the corner frequency (-3 dB according to Colquhoun) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c64c923dcb8f39d644163ab0c09abbe"></a><!-- doxytag: member="stf::fgnabiexp" ref="ga6c64c923dcb8f39d644163ab0c09abbe" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::fgnabiexp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>power of 1 sodium conductance function. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[f(x)=p_0\left(1-\mathrm{e}^{\frac{-x}{p_1}}\right)\mathrm{e}^{\frac{-x}{p_2}} + p_3\]" src="form_18.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
    <tr><td class="paramname">p</td><td>A valarray of parameters, where <br/>
 <em>p</em>[0] is the amplitude <img class="formulaInl" alt="$g'_{Na}$" src="form_15.png"/>, <br/>
 <em>p</em>[1] is <img class="formulaInl" alt="$\tau_m$" src="form_16.png"/>, <br/>
 <em>p</em>[2] is <img class="formulaInl" alt="$\tau_h$" src="form_17.png"/> and <br/>
 <em>p</em>[3] is the offset. <br/>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5454dcb2feefac399c4f5e9d7a277dd7"></a><!-- doxytag: member="stf::fgnabiexp_init" ref="ga5454dcb2feefac399c4f5e9d7a277dd7" args="(const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stf::fgnabiexp_init </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>peak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>pInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialises parameters for fitting stf::falpha() to <em>data</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The waveform of the data for the fit. </td></tr>
    <tr><td class="paramname">base</td><td>Baseline of <em>data</em>. </td></tr>
    <tr><td class="paramname">peak</td><td>Peak value of <em>data</em>. </td></tr>
    <tr><td class="paramname">dt</td><td>The sampling interval. </td></tr>
    <tr><td class="paramname">pInit</td><td>On entry, pass a valarray of size 4. On exit, will contain initial parameter estimates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63447f9728c486a97b390102ff325018"></a><!-- doxytag: member="stf::fHH" ref="ga63447f9728c486a97b390102ff325018" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::fHH </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hodgkin-Huxley sodium conductance function. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[f(x)=p_0\left(1-\mathrm{e}^{\frac{-x}{p_1}}\right)^3\mathrm{e}^{\frac{-x}{p_2}} + p_3\]" src="form_14.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
    <tr><td class="paramname">p</td><td>A valarray of parameters, where <br/>
 <em>p</em>[0] is the amplitude <img class="formulaInl" alt="$g'_{Na}$" src="form_15.png"/>, <br/>
 <em>p</em>[1] is <img class="formulaInl" alt="$\tau_m$" src="form_16.png"/>, <br/>
 <em>p</em>[2] is <img class="formulaInl" alt="$\tau_h$" src="form_17.png"/> and <br/>
 <em>p</em>[3] is the offset. <br/>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="gacaee0bf94446342456475acd827bb1f1"></a><!-- doxytag: member="stf::fHH_init" ref="gacaee0bf94446342456475acd827bb1f1" args="(const Vector_double &amp;data, double base, double peak, double dt, Vector_double &amp;pInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stf::fHH_init </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>peak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>pInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialises parameters for fitting stf::falpha() to <em>data</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The waveform of the data for the fit. </td></tr>
    <tr><td class="paramname">base</td><td>Baseline of <em>data</em>. </td></tr>
    <tr><td class="paramname">peak</td><td>Peak value of <em>data</em>. </td></tr>
    <tr><td class="paramname">dt</td><td>The sampling interval. </td></tr>
    <tr><td class="paramname">pInit</td><td>On entry, pass a valarray of size 4. On exit, will contain initial parameter estimates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8d4bf7a86a487551837817a7d6d09cf1"></a><!-- doxytag: member="stf::filter" ref="ga8d4bf7a86a487551837817a7d6d09cf1" args="(const Vector_double &amp;toFilter, std::size_t filter_start, std::size_t filter_end, const Vector_double &amp;a, int SR, Func func, bool inverse=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector_double stf::filter </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>toFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>filter_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>filter_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolutes a data set with a filter function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">toFilter</td><td>The valarray to be filtered. </td></tr>
    <tr><td class="paramname">filter_start</td><td>The index from which to start filtering. </td></tr>
    <tr><td class="paramname">filter_end</td><td>The index at which to stop filtering. </td></tr>
    <tr><td class="paramname">a</td><td>A valarray of parameters for the filter function. </td></tr>
    <tr><td class="paramname">SR</td><td>The sampling rate. </td></tr>
    <tr><td class="paramname">func</td><td>The filter function in the frequency domain. </td></tr>
    <tr><td class="paramname">inverse</td><td>true if (1- <em>func</em>) should be used as the filter function, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The convoluted data set. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60f83eec1f06c30440d1f576bd5a5f7e"></a><!-- doxytag: member="stf::findType" ref="ga60f83eec1f06c30440d1f576bd5a5f7e" args="(const wxString &amp;ext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__stfgen.html#gae703f7802498ae301ac058b94426900f">stf::filetype</a> stf::findType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwxString.html">wxString</a> &amp;&#160;</td>
          <td class="paramname"><em>ext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to determine the filetype from the filter extension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ext</td><td>The filter extension to be tested (in the form wxT("*.ext")). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The corresponding file type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga96ce124f20c81dcdac988e31770b65c5"></a><!-- doxytag: member="stf::flin" ref="ga96ce124f20c81dcdac988e31770b65c5" args="(double x, const Vector_double &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::flin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Linear function. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[f(x)=p_0 x + p_1\]" src="form_7.png"/>
</p>
 <dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
    <tr><td class="paramname">p</td><td>A valarray of parameters, where <br/>
 <em>p</em>[0] is the slope and <br/>
 <em>p</em>[1] is the y intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The evaluated function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga89d5f83830be9b0132ddb34c5d46d281"></a><!-- doxytag: member="stf::get_scale" ref="ga89d5f83830be9b0132ddb34c5d46d281" args="(Vector_double &amp;data, double oldx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector_double stf::get_scale </td>
          <td>(</td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>oldx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute and perform normalisation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data vector; will be scaled upon return </td></tr>
    <tr><td class="paramname">oldx</td><td>original x interval </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector with <br/>
 [0] x scale [1] x offset [2] y scale [3] y offset </dd></dl>

</div>
</div>
<a class="anchor" id="ga14b43f4510558137aac70408cd1c036b"></a><!-- doxytag: member="stf::GetFuncLib" ref="ga14b43f4510558137aac70408cd1c036b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structstf_1_1storedFunc.html">stf::storedFunc</a>&gt; stf::GetFuncLib </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the library of functions for non-linear regression. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of non-linear regression functions. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa535878b74675e92a48e0e20a7e6b1a6"></a><!-- doxytag: member="stf::getParInfoExp" ref="gaa535878b74675e92a48e0e20a7e6b1a6" args="(int n_exp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;parInfo&gt; stf::getParInfoExp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_exp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates <a class="el" href="structstf_1_1parInfo.html" title="Information about parameters used in storedFunc.">stf::parInfo</a> structs for n-exponential functions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n_exp</td><td>Number of exponential terms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of parameter information structs. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c37983f5e22f103c26a77b09d8206ad"></a><!-- doxytag: member="stf::importFile" ref="ga3c37983f5e22f103c26a77b09d8206ad" args="(const wxString &amp;fName, stf::filetype type, Recording &amp;ReturnData, const stf::txtImportSettings &amp;txtImport, bool progress=true, wxWindow *parent=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stf::importFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwxString.html">wxString</a> &amp;&#160;</td>
          <td class="paramname"><em>fName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stfgen.html#gae703f7802498ae301ac058b94426900f">stf::filetype</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRecording.html">Recording</a> &amp;&#160;</td>
          <td class="paramname"><em>ReturnData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstf_1_1txtImportSettings.html">stf::txtImportSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>txtImport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>progress</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwxWindow.html">wxWindow</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic file import. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fName</td><td>The full path name of the file. </td></tr>
    <tr><td class="paramname">type</td><td>The file type. </td></tr>
    <tr><td class="paramname">ReturnData</td><td>Will contain the file data on return. </td></tr>
    <tr><td class="paramname">txtImport</td><td>The text import filter settings. </td></tr>
    <tr><td class="paramname">progress</td><td>Set to true if a progress dialog should be shown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the file has successfully been read, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gacce99eda0b9fa51555b8b8adbfef7700"></a><!-- doxytag: member="stf::initLinFunc" ref="gacce99eda0b9fa51555b8b8adbfef7700" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstf_1_1storedFunc.html">stf::storedFunc</a> stf::initLinFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initializes a linear function </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="structstf_1_1storedFunc.html" title="Function used for least-squares fitting.">stf::storedFunc</a> that can be used to store a linear function after a fit </dd></dl>

</div>
</div>
<a class="anchor" id="ga278bc04e06ac5796e0867b158ae4797b"></a><!-- doxytag: member="stf::integrate_simpson" ref="ga278bc04e06ac5796e0867b158ae4797b" args="(const Vector_double &amp;input, std::size_t a, std::size_t b, double x_scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::integrate_simpson </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integration using Simpson's rule. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The valarray to be integrated. </td></tr>
    <tr><td class="paramname">a</td><td>Start of the integration interval. </td></tr>
    <tr><td class="paramname">b</td><td>End of the integration interval. </td></tr>
    <tr><td class="paramname">x_scale</td><td>Sampling interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integral of <em>input</em> between <em>a</em> and <em>b</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0be2d046407da1c77424a79fa01924ab"></a><!-- doxytag: member="stf::integrate_trapezium" ref="ga0be2d046407da1c77424a79fa01924ab" args="(const Vector_double &amp;input, std::size_t a, std::size_t b, double x_scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::integrate_trapezium </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integration using the trapezium rule. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The valarray to be integrated. </td></tr>
    <tr><td class="paramname">a</td><td>Start of the integration interval. </td></tr>
    <tr><td class="paramname">b</td><td>End of the integration interval. </td></tr>
    <tr><td class="paramname">x_scale</td><td>Sampling interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integral of <em>input</em> between <em>a</em> and <em>b</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0386bf9c9ceb5499900af490e06e2ab"></a><!-- doxytag: member="stf::linCorr" ref="gaa0386bf9c9ceb5499900af490e06e2ab" args="(const Vector_double &amp;va1, const Vector_double &amp;va2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector_double stf::linCorr </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>va1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>va2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the linear correlation between two arrays. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">va1</td><td>First array. </td></tr>
    <tr><td class="paramname">va2</td><td>Second array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The linear correlation between the two arrays for each data point of <em>va1</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga29e77fd36f4c103444287e9c5b807ab9"></a><!-- doxytag: member="stf::linFit" ref="ga29e77fd36f4c103444287e9c5b807ab9" args="(const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y, T &amp;m, T &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stf::linFit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a linear fit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x- values of the data that are to be fitted. </td></tr>
    <tr><td class="paramname">y</td><td>The y- values of the data that are to be fitted. </td></tr>
    <tr><td class="paramname">m</td><td>On exit, the slope of the regression line. </td></tr>
    <tr><td class="paramname">c</td><td>On exit, the y-intercept of the regression line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valarray containing the waveform of the fitted function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e6063c1fcb15672fb84c44065e32455"></a><!-- doxytag: member="stf::linsolv" ref="ga2e6063c1fcb15672fb84c44065e32455" args="(int m, int n, int nrhs, Vector_double &amp;A, Vector_double &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stf::linsolv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves a linear equation system using LAPACK. </p>
<p>Uses column-major order for matrices. For an example, see <a class="el" href="classSection.html#a8e69591a80dc21c7ecba523ae15eec3d" title="Determines whether an integral has been calculated in this section.">Section::SetIsIntegrated()</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of rows of the matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">n</td><td>Number of columns of the matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of columns of the matrix <em>B</em>. </td></tr>
    <tr><td class="paramname">A</td><td>On entry, the left-hand-side matrix. On exit, the factors L and U from the factorization A = P*L*U; the unit diagonal elements of L are not stored. </td></tr>
    <tr><td class="paramname">B</td><td>On entry, the right-hand-side matrix. On exit, the solution to the linear equation system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>At present, always returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf43d0ea16185a30745919255f231c80"></a><!-- doxytag: member="stf::lmFit" ref="gacf43d0ea16185a30745919255f231c80" args="(const Vector_double &amp;data, double dt, const stf::storedFunc &amp;fitFunc, const Vector_double &amp;opts, bool use_scaling, Vector_double &amp;p, wxString &amp;info, int &amp;warning)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double StfDll stf::lmFit </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstf_1_1storedFunc.html">stf::storedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>fitFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwxString.html">wxString</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>warning</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the Levenberg-Marquardt algorithm to perform a non-linear least-squares fit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A valarray containing the data. </td></tr>
    <tr><td class="paramname">dt</td><td>The sampling interval of <em>data</em>. </td></tr>
    <tr><td class="paramname">fitFunc</td><td>An <a class="el" href="structstf_1_1storedFunc.html" title="Function used for least-squares fitting.">stf::storedFunc</a> to be fitted to <em>data</em>. </td></tr>
    <tr><td class="paramname">opts</td><td>Options controlling Lourakis' implementation of the algorithm. </td></tr>
    <tr><td class="paramname">use_scaling</td><td>Whether to scale x and y-amplitudes to 1.0 </td></tr>
    <tr><td class="paramname">p</td><td><em>func's</em> parameters. Should be set to an initial guess on entry. Will contain the best-fit values on exit. </td></tr>
    <tr><td class="paramname">info</td><td>Information about why the fit stopped iterating </td></tr>
    <tr><td class="paramname">warning</td><td>A warning code on return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sum of squred errors between <em>data</em> and the best-fit function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7aea0ee12af70b3eb64016585df82eeb"></a><!-- doxytag: member="stf::maxDecay" ref="ga7aea0ee12af70b3eb64016585df82eeb" args="(const std::vector&lt; double &gt; &amp;data, double left, double right, double &amp;maxDecayT, double &amp;maxDecayY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::maxDecay </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>maxDecayT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>maxDecayY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the maximal slope during the decaying phase of an event within <em>data</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data waveform to be analysed. </td></tr>
    <tr><td class="paramname">left</td><td>Delimits the search to the left. </td></tr>
    <tr><td class="paramname">right</td><td>Delimits the search to the right. </td></tr>
    <tr><td class="paramname">maxDecayT</td><td>The interpolated time point of the maximal slope of decay in units of sampling points. </td></tr>
    <tr><td class="paramname">maxDecayY</td><td>The interpolated value of <em>data</em> at <em>maxDecayT</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximal slope during the decaying phase. </dd></dl>

<p>Referenced by <a class="el" href="classRecording.html#a10828c1a1db5f3a452ef6d4558a3cf05">Recording::GetMaxDecay()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3fe029fabcdd9669244b896cd57fede3"></a><!-- doxytag: member="stf::maxRise" ref="ga3fe029fabcdd9669244b896cd57fede3" args="(const std::vector&lt; double &gt; &amp;data, double left, double right, double &amp;maxRiseT, double &amp;maxRiseY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::maxRise </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>maxRiseT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>maxRiseY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the maximal slope during the rising phase of an event within <em>data</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data waveform to be analysed. </td></tr>
    <tr><td class="paramname">left</td><td>Delimits the search to the left. </td></tr>
    <tr><td class="paramname">right</td><td>Delimits the search to the right. </td></tr>
    <tr><td class="paramname">maxRiseT</td><td>The interpolated time point of the maximal slope of rise in units of sampling points. </td></tr>
    <tr><td class="paramname">maxRiseY</td><td>The interpolated value of <em>data</em> at <em>maxRiseT</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximal slope during the rising phase. </dd></dl>

<p>Referenced by <a class="el" href="classRecording.html#aabad745e2588229871cb5b09727f65dd">Recording::GetMaxRise()</a>.</p>

</div>
</div>
<a class="anchor" id="gad14c86e14d611fd5c11eca4edfbb4fb8"></a><!-- doxytag: member="stf::noPath" ref="gad14c86e14d611fd5c11eca4edfbb4fb8" args="(const wxString &amp;fName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwxString.html">wxString</a> stf::noPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwxString.html">wxString</a> &amp;&#160;</td>
          <td class="paramname"><em>fName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Strips the directory off a full path name, returns only the filename. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fName</td><td>The full path of a file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The file name without the directory. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62fd233e1b8aaa7e71bcc639793b3c93"></a><!-- doxytag: member="stf::outputWTau" ref="ga62fd233e1b8aaa7e71bcc639793b3c93" args="(const Vector_double &amp;p, const std::vector&lt; parInfo &gt; &amp;parsInfo, double chisqr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstf_1_1Table.html">stf::Table</a> stf::outputWTau </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; parInfo &gt; &amp;&#160;</td>
          <td class="paramname"><em>parsInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>chisqr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates a weighted time constant. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Parameters of an exponential function (see stf::fexp()). </td></tr>
    <tr><td class="paramname">parsInfo</td><td>Information about the parameters <em>p</em>. </td></tr>
    <tr><td class="paramname">chisqr</td><td>The sum of squared errors, as returned from a least-squares fit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A formatted table of results. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f30710d3729c00c31a1aa82d08badff"></a><!-- doxytag: member="stf::peak" ref="ga0f30710d3729c00c31a1aa82d08badff" args="(const std::vector&lt; double &gt; &amp;data, double base, std::size_t llp, std::size_t ulp, int pM, stf::direction, double &amp;maxT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::peak </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>llp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ulp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stfgen.html#gae8845ae2aeaf4b742a905a2a5571fd5a">stf::direction</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>maxT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the peak value of <em>data</em> between <em>llp</em> and <em>ulp</em>. </p>
<p>Note that peaks will be detected by measuring from <em>base</em>, but the return value is given from 0. Data points at both <em>llp</em> and <em>ulp</em> will be included in the search (legacy of Stimfit for PASCAL). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data waveform to be analysed. </td></tr>
    <tr><td class="paramname">base</td><td>The baseline value. </td></tr>
    <tr><td class="paramname">llp</td><td>Lower limit of the peak window. </td></tr>
    <tr><td class="paramname">ulp</td><td>Upper limit of the peak window. </td></tr>
    <tr><td class="paramname">pM</td><td>If <em>pM</em> &gt; 1, a sliding (boxcar) average of width <em>pM</em> will be used to measure the peak. </td></tr>
    <tr><td class="paramname">dir</td><td>Can be <br/>
 stf::up for positive-going peaks, <br/>
 stf::down for negative-going peaks or <br/>
 stf::both for negative- or positive-going peaks, whichever is larger. </td></tr>
    <tr><td class="paramname">maxT</td><td>On exit, the index of the peak value. May be interpolated if <em>pM</em> &gt; 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The peak value, measured from 0. </dd></dl>

<p>Referenced by <a class="el" href="classRecording.html#aac9e484d34cd41ee08d03e7d9dffbfc1">Recording::GetPeak()</a>.</p>

</div>
</div>
<a class="anchor" id="ga211ecf55c013f280fd1a87d9b762f79e"></a><!-- doxytag: member="stf::peakIndices" ref="ga211ecf55c013f280fd1a87d9b762f79e" args="(const Vector_double &amp;data, double threshold, int minDistance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; stf::peakIndices </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches for positive-going peaks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The valarray to be searched for peaks. </td></tr>
    <tr><td class="paramname">threshold</td><td>Minimal amplitude of a peak. </td></tr>
    <tr><td class="paramname">minDistance</td><td>Minimal distance between subsequent peaks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of indices where peaks have occurred in <em>data</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac8474c28c6c1e5cce375823a1d38591d"></a><!-- doxytag: member="stf::pow2" ref="gac8474c28c6c1e5cce375823a1d38591d" args="(int arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stf::pow2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes <img class="formulaInl" alt="$ 2^{arg} $" src="form_6.png"/>. Uses the bitwise-shift operator (&lt;&lt;). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Argument of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><img class="formulaInl" alt="$ 2^{arg} $" src="form_6.png"/>. </dd></dl>

</div>
</div>
<a class="anchor" id="gada6c5911cfc604b337b76d1198d8cd37"></a><!-- doxytag: member="stf::risetime" ref="gada6c5911cfc604b337b76d1198d8cd37" args="(const std::vector&lt; double &gt; &amp;data, double base, double ampl, double left, double right, std::size_t &amp;t20Id, std::size_t &amp;t80Id, double &amp;t20Real)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::risetime </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ampl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>t20Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>t80Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t20Real</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find 20 to 80% rise time of an event in <em>data</em>. </p>
<p>Although t80real is not explicitly returned, it can be calculated from t20Real+risetime. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data waveform to be analysed. </td></tr>
    <tr><td class="paramname">base</td><td>The baseline value. </td></tr>
    <tr><td class="paramname">ampl</td><td>The amplitude of the event (typically, peak-base). </td></tr>
    <tr><td class="paramname">left</td><td>Delimits the search to the left. </td></tr>
    <tr><td class="paramname">right</td><td>Delimits the search to the right. </td></tr>
    <tr><td class="paramname">t20Id</td><td>On exit, the index wich is closest to the 20-point. </td></tr>
    <tr><td class="paramname">t80Id</td><td>On exit, the index wich is closest to the 80-point. </td></tr>
    <tr><td class="paramname">t20Real</td><td>the linearly interpolated 20-timepoint in units of sampling points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The rise time. </dd></dl>

</div>
</div>
<a class="anchor" id="ga555e6d942a4dc2437482dbe9c5fed9ab"></a><!-- doxytag: member="stf::round" ref="ga555e6d942a4dc2437482dbe9c5fed9ab" args="(double toRound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stf::round </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>toRound</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does what it says. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">toRound</td><td>The double to be rounded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The rounded integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9536c899dc7a569c55ba8957aec43613"></a><!-- doxytag: member="stf::sectionToString" ref="ga9536c899dc7a569c55ba8957aec43613" args="(const Section &amp;section)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwxString.html">wxString</a> stf::sectionToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSection.html">Section</a> &amp;&#160;</td>
          <td class="paramname"><em>section</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a <a class="el" href="classSection.html" title="Represents a continuously sampled sweep of data points.">Section</a> to a <a class="el" href="classwxString.html" title="See http://www.wxwidgets.org/manuals/stable/wx_wxstring.html (wxWidgets documentation)">wxString</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">section</td><td>The <a class="el" href="classSection.html" title="Represents a continuously sampled sweep of data points.">Section</a> to be written to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the x- and y-values of the section in two columns. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fcd50c88877838de7ed4b52e1fedb59"></a><!-- doxytag: member="stf::spectrum" ref="ga2fcd50c88877838de7ed4b52e1fedb59" args="(const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;data, long K, double &amp;f_n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector_double stf::spectrum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>f_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a spectral estimate using Welch's method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>An input valarray of complex numbers. </td></tr>
    <tr><td class="paramname">K</td><td><em>data</em> will be split into <em>K</em> windows. </td></tr>
    <tr><td class="paramname">f_n</td><td>On return, this contains the frequency step between adjacent indices in the spectrum, in units of 1/index_data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valarray containing the spectrum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62f78deb330cc40d8ae6da48cdbec951"></a><!-- doxytag: member="stf::SQR" ref="ga62f78deb330cc40d8ae6da48cdbec951" args="(T a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stf::SQR </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the square of a number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>a</em> ^2 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c43d9ceb4e7ce199c0278b52e28386d"></a><!-- doxytag: member="stf::t_half" ref="ga7c43d9ceb4e7ce199c0278b52e28386d" args="(const std::vector&lt; double &gt; &amp;data, double base, double ampl, double left, double right, double center, std::size_t &amp;t50LeftId, std::size_t &amp;t50RightId, double &amp;t50LeftReal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::t_half </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ampl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>t50LeftId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>t50RightId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t50LeftReal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the full width at half-maximal amplitude of an event within <em>data</em>. </p>
<p>Although t50RightReal is not explicitly returned, it can be calculated from t50LeftReal+t_half. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data waveform to be analysed. </td></tr>
    <tr><td class="paramname">base</td><td>The baseline value. </td></tr>
    <tr><td class="paramname">ampl</td><td>The amplitude of the event (typically, peak-base). </td></tr>
    <tr><td class="paramname">left</td><td>Delimits the search to the left. </td></tr>
    <tr><td class="paramname">right</td><td>Delimits the search to the right. </td></tr>
    <tr><td class="paramname">center</td><td>The estimated center of an event from which to start searching to the left and to the right (typically, the index of the peak). </td></tr>
    <tr><td class="paramname">t50LeftId</td><td>On exit, the index wich is closest to the left 50-point. </td></tr>
    <tr><td class="paramname">t50RightId</td><td>On exit, the index wich is closest to the right 50-point. </td></tr>
    <tr><td class="paramname">t50LeftReal</td><td>the linearly interpolated left 50-timepoint in units of sampling points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The full width at half-maximal amplitude. </dd></dl>

</div>
</div>
<a class="anchor" id="gaafcb097f10d8179f38881321d7cd86f3"></a><!-- doxytag: member="stf::threshold" ref="gaafcb097f10d8179f38881321d7cd86f3" args="(const std::vector&lt; double &gt; &amp;data, std::size_t llp, std::size_t ulp, double slope, double &amp;thrT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::threshold </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>llp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ulp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>thrT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the value within <em>data</em> between <em>llp</em> and <em>ulp</em> at which <em>slope</em> is exceeded. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data waveform to be analysed. </td></tr>
    <tr><td class="paramname">llp</td><td>Lower limit of the peak window. </td></tr>
    <tr><td class="paramname">ulp</td><td>Upper limit of the peak window. </td></tr>
    <tr><td class="paramname">thrT</td><td>On exit, The interpolated time point of the threshold crossing in units of sampling points, or a negative value if the threshold wasn't found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The interpolated threshold value. </dd></dl>

<p>Referenced by <a class="el" href="classRecording.html#a60b49830249c73a6d8267b94afcc7fbb">Recording::GetThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7fa85af19cf73937c166e0fa1aad7955"></a><!-- doxytag: member="stf::whereis" ref="ga7fa85af19cf73937c166e0fa1aad7955" args="(const Vector_double &amp;data, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t stf::whereis </td>
          <td>(</td>
          <td class="paramtype">const Vector_double &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the index of <em>data</em> where <em>value</em> is encountered for the first time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The waveform to be searched. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of <em>data</em> right after <em>value</em> has been crossed. </dd></dl>

</div>
</div>
<a class="anchor" id="gacdf87f88e8ac06ad60a3f3b206b0cd91"></a><!-- doxytag: member="stf::window" ref="gacdf87f88e8ac06ad60a3f3b206b0cd91" args="(double n, double N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::window </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Window function for psd estimation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Argument of the window function. </td></tr>
    <tr><td class="paramname">N</td><td>Width of the window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Result of the window function. </dd></dl>

</div>
</div>
<a class="anchor" id="gabe31dea1c4b9c10627815f17c56f4549"></a><!-- doxytag: member="stf::xscale" ref="gabe31dea1c4b9c10627815f17c56f4549" args="(double param, double xscale, double xoff, double yscale, double yoff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::xscale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a parameter that linearly depends on x. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>parameter to scale </td></tr>
    <tr><td class="paramname">xscale</td><td>x scaling factor </td></tr>
    <tr><td class="paramname">xoff</td><td>x offset </td></tr>
    <tr><td class="paramname">yscale</td><td>y scaling factor </td></tr>
    <tr><td class="paramname">yoff</td><td>y offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Scaled parameter </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f08b8e36843ae1e5ef9b285cc5f86b7"></a><!-- doxytag: member="stf::xunscale" ref="ga3f08b8e36843ae1e5ef9b285cc5f86b7" args="(double param, double xscale, double xoff, double yscale, double yoff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::xunscale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unscales a parameter that linearly depends on x. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>parameter to scale </td></tr>
    <tr><td class="paramname">xscale</td><td>x scaling factor </td></tr>
    <tr><td class="paramname">xoff</td><td>x offset </td></tr>
    <tr><td class="paramname">yscale</td><td>y scaling factor </td></tr>
    <tr><td class="paramname">yoff</td><td>y offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unscaled parameter </dd></dl>

</div>
</div>
<a class="anchor" id="ga00c92887edc6d459207573419ede56ef"></a><!-- doxytag: member="stf::yscale" ref="ga00c92887edc6d459207573419ede56ef" args="(double param, double xscale, double xoff, double yscale, double yoff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::yscale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a parameter that linearly depends on y. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>parameter to scale </td></tr>
    <tr><td class="paramname">xscale</td><td>x scaling factor </td></tr>
    <tr><td class="paramname">xoff</td><td>x offset </td></tr>
    <tr><td class="paramname">yscale</td><td>y scaling factor </td></tr>
    <tr><td class="paramname">yoff</td><td>y offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae9d5e4c6d163781154d54888906e3928"></a><!-- doxytag: member="stf::yscaleoffset" ref="gae9d5e4c6d163781154d54888906e3928" args="(double param, double xscale, double xoff, double yscale, double yoff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::yscaleoffset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a parameter that linearly depends on y and adds an offset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>parameter to scale </td></tr>
    <tr><td class="paramname">xscale</td><td>x scaling factor </td></tr>
    <tr><td class="paramname">xoff</td><td>x offset </td></tr>
    <tr><td class="paramname">yscale</td><td>y scaling factor </td></tr>
    <tr><td class="paramname">yoff</td><td>y offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7d081bd58e0107dc245a8441e45e3929"></a><!-- doxytag: member="stf::yunscale" ref="ga7d081bd58e0107dc245a8441e45e3929" args="(double param, double xscale, double xoff, double yscale, double yoff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::yunscale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unscales a parameter that linearly depends on y. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>parameter to scale </td></tr>
    <tr><td class="paramname">xscale</td><td>x scaling factor </td></tr>
    <tr><td class="paramname">xoff</td><td>x offset </td></tr>
    <tr><td class="paramname">yscale</td><td>y scaling factor </td></tr>
    <tr><td class="paramname">yoff</td><td>y offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unscaled parameter </dd></dl>

</div>
</div>
<a class="anchor" id="gab000f4b8bc54c11315091c912ba0c1e0"></a><!-- doxytag: member="stf::yunscaleoffset" ref="gab000f4b8bc54c11315091c912ba0c1e0" args="(double param, double xscale, double xoff, double yscale, double yoff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stf::yunscaleoffset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yscale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unscales a parameter that linearly depends on y and removes the offset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>parameter to scale </td></tr>
    <tr><td class="paramname">xscale</td><td>x scaling factor </td></tr>
    <tr><td class="paramname">xoff</td><td>x offset </td></tr>
    <tr><td class="paramname">yscale</td><td>y scaling factor </td></tr>
    <tr><td class="paramname">yoff</td><td>y offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unscaled parameter </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 30 2011 22:43:08 for stimfit by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
