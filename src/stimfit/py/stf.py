# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


"""
The stf module allows to access a running stimfit
application from the embedded python shell.
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_stf', [dirname(__file__)])
        except ImportError:
            import _stf
            return _stf
        if fp is not None:
            try:
                _mod = imp.load_module('_stf', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _stf = swig_import_helper()
    del swig_import_helper
else:
    import _stf
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _stf.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _stf.SwigPyIterator_value(self)
    def incr(self, n=1): return _stf.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _stf.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _stf.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _stf.SwigPyIterator_equal(self, *args)
    def copy(self): return _stf.SwigPyIterator_copy(self)
    def next(self): return _stf.SwigPyIterator_next(self)
    def __next__(self): return _stf.SwigPyIterator___next__(self)
    def previous(self): return _stf.SwigPyIterator_previous(self)
    def advance(self, *args): return _stf.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _stf.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _stf.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _stf.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _stf.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _stf.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _stf.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _stf.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class vectord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectord, name)
    __repr__ = _swig_repr
    def iterator(self): return _stf.vectord_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _stf.vectord___nonzero__(self)
    def __bool__(self): return _stf.vectord___bool__(self)
    def __len__(self): return _stf.vectord___len__(self)
    def pop(self): return _stf.vectord_pop(self)
    def __getslice__(self, *args): return _stf.vectord___getslice__(self, *args)
    def __setslice__(self, *args): return _stf.vectord___setslice__(self, *args)
    def __delslice__(self, *args): return _stf.vectord___delslice__(self, *args)
    def __delitem__(self, *args): return _stf.vectord___delitem__(self, *args)
    def __getitem__(self, *args): return _stf.vectord___getitem__(self, *args)
    def __setitem__(self, *args): return _stf.vectord___setitem__(self, *args)
    def append(self, *args): return _stf.vectord_append(self, *args)
    def empty(self): return _stf.vectord_empty(self)
    def size(self): return _stf.vectord_size(self)
    def clear(self): return _stf.vectord_clear(self)
    def swap(self, *args): return _stf.vectord_swap(self, *args)
    def get_allocator(self): return _stf.vectord_get_allocator(self)
    def begin(self): return _stf.vectord_begin(self)
    def end(self): return _stf.vectord_end(self)
    def rbegin(self): return _stf.vectord_rbegin(self)
    def rend(self): return _stf.vectord_rend(self)
    def pop_back(self): return _stf.vectord_pop_back(self)
    def erase(self, *args): return _stf.vectord_erase(self, *args)
    def __init__(self, *args): 
        this = _stf.new_vectord(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _stf.vectord_push_back(self, *args)
    def front(self): return _stf.vectord_front(self)
    def back(self): return _stf.vectord_back(self)
    def assign(self, *args): return _stf.vectord_assign(self, *args)
    def resize(self, *args): return _stf.vectord_resize(self, *args)
    def insert(self, *args): return _stf.vectord_insert(self, *args)
    def reserve(self, *args): return _stf.vectord_reserve(self, *args)
    def capacity(self): return _stf.vectord_capacity(self)
    __swig_destroy__ = _stf.delete_vectord
    __del__ = lambda self : None;
vectord_swigregister = _stf.vectord_swigregister
vectord_swigregister(vectord)


def get_versionstring():
  """
    get_versionstring() -> std::string

    Returns the current version of Stimfit.
    """
  return _stf.get_versionstring()

def get_trace(*args, **kwargs):
  """
    get_trace(trace=-1, channel=-1) -> PyObject *

    Returns a trace as a 1-dimensional NumPy array.

    Arguments:       
    trace --   ZERO-BASED index of the trace within the channel.
               Note that this is one less than what is shown
               in the drop-down box.
               The default value of -1 returns the currently
               displayed trace.
    channel -- ZERO-BASED index of the channel. This is independent
               of whether a channel is active or not.
               The default value of -1 returns the currently
               active channel.
    Returns:
    The trace as a 1D NumPy array.
    """
  return _stf.get_trace(*args, **kwargs)

def new_window(*args):
  """
    new_window(invec) -> bool

    Creates a new window showing a
    1D NumPy array.
          
    Arguments:
    invec --   The NumPy array to be shown.

    Returns:
    True upon successful completion, false otherwise.
    """
  return _stf.new_window(*args)

def _new_window_gMatrix():
  """
    _new_window_gMatrix() -> bool

    Creates a new window from the global matrix.
    Do not use directly.
    """
  return _stf._new_window_gMatrix()

def new_window_matrix(*args):
  """
    new_window_matrix(inarr) -> bool

    Creates a new window showing a
    2D NumPy array.
          
    Arguments:
    inarr --   The NumPy array to be shown. First dimension
               are the traces, second dimension the sampling
               points within the traces.

    Returns:
    True upon successful completion, false otherwise.
    """
  return _stf.new_window_matrix(*args)

def new_window_selected_this():
  """
    new_window_selected_this() -> bool

    Creates a new window showing the
    selected traces of the current file.
    Returns:
    True if successful.
    """
  return _stf.new_window_selected_this()

def new_window_selected_all():
  """
    new_window_selected_all() -> bool

    Creates a new window showing the
    selected traces of all open files.
    Returns:
    True if successful.
    """
  return _stf.new_window_selected_all()

def show_table(*args, **kwargs):
  """
    show_table(dict, caption="Python table") -> bool

    Shows a python dictionary in a results table.
    The dictionary has to have the form "string" : float

    Arguments:
    dict --    A dictionary with strings as key values and floating point
               numbers as values.
    caption -- An optional caption for the table.

    Returns:
    True if successful.
    """
  return _stf.show_table(*args, **kwargs)

def show_table_dictlist(*args, **kwargs):
  """
    show_table_dictlist(dict, caption="Python table", reverse=True) -> bool

    Shows a python dictionary in a results table.
    The dictionary has to have the form "string" : list. 

    Arguments:
    dict --    A dictionary with strings as key values and lists of 
               floating point numbers as values.
    caption -- An optional caption for the table.
    reverse -- If True, The table will be filled in column-major order,
               i.e. dictionary keys will become column titles. Setting
               it to False has not been implemented yet.

    Returns:
    True if successful.
    """
  return _stf.show_table_dictlist(*args, **kwargs)

def get_size_trace(*args, **kwargs):
  """
    get_size_trace(trace=-1, channel=-1) -> int

    Retrieves the number of sample points of a trace.
       
    Arguments:
    trace --   ZERO-BASED index of the trace. Default value of -1
               will use the currently displayed trace. Note that
               this is one less than what is displayed in the drop-
               down list.
    channel -- ZERO-BASED index of the channel. Default value of
               -1 will use the current channel.
    Returns:
    The number of sample points.
    """
  return _stf.get_size_trace(*args, **kwargs)

def get_size_channel(*args, **kwargs):
  """
    get_size_channel(channel=-1) -> int

    Retrieves the number of traces in a channel.
    Note that at present, stimfit only supports equal-sized channels, i.e. 
    all channels within a file need to have the same number of traces. The
    channel argument is only for future extensions. 
       
    Arguments:
    channel -- ZERO-BASED index of the channel. Default value of
               -1 will use the current channel. 
    Returns:
    The number traces in a channel.
    """
  return _stf.get_size_channel(*args, **kwargs)

def get_maxdecay():
  """
    get_maxdecay() -> double

    Retrieves the maximal slope of the decay 
    between the peak cursors in the current trace. Uses the currently 
    measured values, i.e. does not update measurements if the peak window 
    cursors have changed.
      
       
    Returns:
    The maximal slope of the decay, -1.0 upon failure.
    """
  return _stf.get_maxdecay()

def get_maxrise():
  """
    get_maxrise() -> double

    Retrieves the maximal slope of the rise 
    between the peak cursors in the current trace. Uses the currently 
    measured values, i.e. does not update measurements if the peak window 
    cursors have changed.

       
    Returns:
    The maximal slope of the rise, -1.0 upon failure.
    """
  return _stf.get_maxrise()

def get_size_recording():
  """
    get_size_recording() -> int

    Retrieves the number of channels in a 
    recording.
       
    Returns:
    The number of channels in a recording.
    """
  return _stf.get_size_recording()

def get_sampling_interval():
  """
    get_sampling_interval() -> double

    Returns the sampling interval.

    Returns:
    The sampling interval.
    """
  return _stf.get_sampling_interval()

def get_xunits():
  """
    get_xunits() -> char const *

    Returns the x units of the specified section.
    X units are assumed to be the same for the entire file.

    Returns:
    The x units as a string.
    """
  return _stf.get_xunits()

def get_yunits(*args, **kwargs):
  """
    get_yunits(trace=-1, channel=-1) -> char const *

    Returns the y units of the specified trace.
    Y units are not allowed to change between traces at present.

    Arguments:
    trace -- The zero-based index of the trace of interest. If < 0, the
          	   name of the active trace will be returned.
    channel -- The zero-based index of the channel of interest. If < 0, the
          	   active channel will be used.

    Returns:
    The x units as a string.
    """
  return _stf.get_yunits(*args, **kwargs)

def set_yunits(*args, **kwargs):
  """
    set_yunits(units, trace=-1, channel=-1) -> bool

    Sets the y unit string of the specified trace.
    Y units are not allowed to change between traces at present.

    Arguments:
    units --   The new y unit string.
    trace --   The zero-based index of the trace of interest. If < 0, the
          	   name of the active trace will be returned.
    channel -- The zero-based index of the channel of interest. If < 0, the
          	   active channel will be used.

    Returns:
    True if successful.
    """
  return _stf.set_yunits(*args, **kwargs)

def set_xunits(*args, **kwargs):
  """
    set_xunits(units) -> bool

    Sets the x unit string for the entire file.

    Arguments:
    units --   The new x unit string.

    Returns:
    True if successful.
    """
  return _stf.set_xunits(*args, **kwargs)

def set_sampling_interval(*args):
  """
    set_sampling_interval(si) -> bool

    Sets a new sampling interval.

    Argument:
    si --     The new sampling interval.

    Returns:
    False upon failure.
    """
  return _stf.set_sampling_interval(*args)

def select_trace(*args, **kwargs):
  """
    select_trace(trace=-1) -> bool

    Selects a trace. Checks for out-of-range
    indices and stores the baseline along with the trace index.
       
    Arguments:
    trace --   ZERO-BASED index of the trace. Default value of -1
               will select the currently displayed trace. Note that
               this is one less than what is displayed in the drop-
               down list.
    Returns:
    True if the trace could be selected, False otherwise.
    """
  return _stf.select_trace(*args, **kwargs)

def select_all():
  """
    select_all()

    Selects all traces in the current file. Stores 
    the baseline along with the trace index.
    """
  return _stf.select_all()

def unselect_all():
  """
    unselect_all()

    Unselects all previously selected traces in the
    current file.
    """
  return _stf.unselect_all()

def subtract_base():
  """
    subtract_base() -> bool

    Subtracts the baseline from the selected traces
    of the current file, then displays the subtracted
    traces in a new window.

    Returns:
    True if the subtraction was successful, False otherwise.
    """
  return _stf.subtract_base()

def leastsq(*args, **kwargs):
  """
    leastsq(fselect, refresh=True) -> PyObject *

    Fits a function to the data between the current
    fit cursors.

    Arguments:
    fselect -- Zero-based index of the function as it appears in the fit
               selection dialog.
    refresh -- To avoid flicker during batch analysis, this may be set to
               False so that the fitted function will not immediately
               be drawn.

    Returns:
    A dictionary with the best-fit parameters and the least-squared
    error, or a null pointer upon failure.
    """
  return _stf.leastsq(*args, **kwargs)

def get_fit(*args, **kwargs):
  """
    get_fit(trace=-1, channel=-1) -> PyObject *

    Get the waveform resulted from the fitting, if available.

    Arguments:
    trace -- The zero-based index of the trace of interest. If < 0, the
          	   name of the active trace will be returned.
    channel -- The zero-based index of the channel of interest. If < 0, the
          	   active channel will be used.

    Returns:
    A 2D Numpy array with the x-values of the fit in the first dimension, and the y-values in the second dimension. None if no fit is available.
    """
  return _stf.get_fit(*args, **kwargs)

def leastsq_param_size(*args):
  """
    leastsq_param_size(fselect) -> int

    Retrieves the number of parameters for a
    function.

    Arguments:
    fselect -- Zero-based index of the function as it appears in the fit
               selection dialog.

    Returns:
    The number of parameters for the function with index fselect, or a 
    negative value upon failure.
    """
  return _stf.leastsq_param_size(*args)

def check_doc(show_dialog=True):
  """
    check_doc(show_dialog=True) -> bool
    check_doc() -> bool

    Checks whether a file is open.

    Arguments:
    show_dialog -- True if an error dialog should be shown if no file is
                   open.

    Returns:
    True if a file is open, False otherwise.
    """
  return _stf.check_doc(show_dialog)

def get_filename():
  """
    get_filename() -> std::string

    Returns the name of the current file.
    """
  return _stf.get_filename()

def _gMatrix_resize(*args):
  """
    _gMatrix_resize(channels, sections)

    Resizes the global matrix. Do not use directly.
       
    Arguments:
    channels -- New number of channels of the global matrix.
    sections -- New number of sections of the global matrix.


    """
  return _stf._gMatrix_resize(*args)

def _gMatrix_at(*args):
  """
    _gMatrix_at(invec, channel, section)

    Sets the valarray at the specified position of
    the global matrix. Do not use directly.
    Arguments:
    invec --   The NumPy array to be used.
    channel -- The channel index within the global matrix.
    section -- The seciton index within the global matrix.

    """
  return _stf._gMatrix_at(*args)

def _gNames_resize(*args):
  """
    _gNames_resize(channels)

    Resizes the global names. Do not use directly.
       
    Arguments:
    channels -- New number of channels of the global names.


    """
  return _stf._gNames_resize(*args)

def _gNames_at(*args):
  """
    _gNames_at(name, channel)

    Sets the channel name of the specifies channel.
    Do not use directly.
    Arguments:
    name --   The new channel name
    channel -- The channel index within the global names.

    """
  return _stf._gNames_at(*args)

def file_open(*args):
  """
    file_open(filename) -> bool

    Opens a file.
       
    Arguments:
    filename -- The file to be opened. On Windows, use double back-
                slashes ("\\\\") between directories to avoid con-
                version to special characters such as "\\t" or "\\n".
                Example usage in Windows:
                file_open("C:\\\data\\\datafile.dat")
                Example usage in Linux:
                file_open("/home/cs/data/datafile.dat")
                This is surprisingly slow when called from python. 
                Haven't figured out the reason yet.

    Returns:
    True if the file could be opened, False otherwise.
    """
  return _stf.file_open(*args)

def file_save(*args):
  """
    file_save(filename) -> bool

    Saves a file.
       
    Arguments:
    filename -- The file to be saved. On Windows, use double back-
                slashes ("\\\\") between directories to avoid con-
                version to special characters such as "\\t" or "\\n".
                Example usage in Windows:
                file_save("C:\\\data\\\datafile.dat")
                Example usage in Linux:
                file_save("/home/cs/data/datafile.dat")
                This is surprisingly slow when called from python. 
                Haven't figured out the reason yet.

    Returns:
    True if the file could be saved, False otherwise.
    """
  return _stf.file_save(*args)

def get_recording_time():
  """
    get_recording_time() -> char const *

    Returns the time at which the recording was 
    started as a string.
    """
  return _stf.get_recording_time()

def get_recording_date():
  """
    get_recording_date() -> char const *

    Returns the date at which the recording was 
    started as a string.
    """
  return _stf.get_recording_date()

def get_recording_comment():
  """
    get_recording_comment() -> std::string

    Returns a comment about the recording.

    """
  return _stf.get_recording_comment()

def set_recording_date(*args):
  """
    set_recording_date(date) -> bool

    Sets a date about the recording.

    Argument:
    date -- A date string.

    Returns:
    True upon successful completion.
    """
  return _stf.set_recording_date(*args)

def set_recording_time(*args):
  """
    set_recording_time(time) -> bool

    Sets a time about the recording.

    Argument:
    time -- A time string.

    Returns:
    True upon successful completion.
    """
  return _stf.set_recording_time(*args)

def set_recording_comment(*args):
  """
    set_recording_comment(comment) -> bool

    Sets a comment about the recording.

    Argument:
    comment -- A comment string.

    Returns:
    True upon successful completion.
    """
  return _stf.set_recording_comment(*args)

def close_all():
  """
    close_all() -> bool

    Closes all open files.
       
    Returns:
    True if all files could be closed.
    """
  return _stf.close_all()

def close_this():
  """
    close_this() -> bool

    Closes the currently active file.
       
    Returns:
    True if the file could be closed.
    """
  return _stf.close_this()

def get_base(active=True):
  """
    get_base(active=True) -> double

    Returns the current baseline value. Uses the 
    currently measured values, i.e. does not update measurements if the 
    peak or base window cursors have changed.

    Arguments:
    active -- If True, returns the baseline in the active channel. If False
              returns the baseline within the reference channel.

    Returns:
    The current baseline.
    """
  return _stf.get_base(active)

def get_peak():
  """
    get_peak() -> double

    Returns the current peak value, measured from
    zero (!). Uses the currently measured values, i.e. does not update 
    measurements if the peak or base window cursors have changed.
             
    Returns:
    The current peak value, measured from zero (again: !).
    """
  return _stf.get_peak()
peak_index_cb = _stf.peak_index_cb

def peak_index(active=True):
  """
    peak_index(active=True) -> double

    Returns the zero-based index of the current
    peak position in the specified channel. Uses the currently measured
    values, i.e. does not update measurements if the peak window cursors
    have changed.
       
    Arguments:
    active -- If True, returns the current peak index of the active channel.
              Otherwise, returns the current peak index of the reference channel.
              
    Returns:
    The zero-based index in units of sampling points. May be interpolated
    if more than one point is used for the peak calculation. Returns a 
    negative value upon failure.
    """
  return _stf.peak_index(active)
peak_index = _stf.peak_index
maxrise_index_cb = _stf.maxrise_index_cb

def maxrise_index(active=True):
  """
    maxrise_index(active=True) -> double

    Returns the zero-based index of the maximal
    slope of rise in the specified channel. Uses the currently measured
    values, i.e. does not update measurements if the peak window cursors
    have changed.
       
    Arguments:
    active -- If True, returns the current index of the maximal slope of 
              rise within the active channel. Otherwise, returns the 
              current index of the maximal slope of rise within the 
              reference channel.
              
    Returns:
    The zero-based index of the maximal slope of  rise in units of 
    sampling points interpolated between adjacent sampling points.
    Returns a negative value upon failure.
    """
  return _stf.maxrise_index(active)
maxrise_index = _stf.maxrise_index

def maxdecay_index():
  """
    maxdecay_index() -> double

    Returns the zero-based index of the maximal
    slope of decay in the current channel. Uses the currently measured
    values, i.e. does not update measurements if the peak window cursors
    have changed. Note that in contrast to maxrise_index, this function 
    only works on the active channel.
       
    Returns:
    The zero-based index of the maximal slope of decay in units of 
    sampling points interpolated between adjacent sampling points.
    Returns a negative value upon failure.
    """
  return _stf.maxdecay_index()
maxdecay_index = _stf.maxdecay_index
foot_index_cb = _stf.foot_index_cb

def foot_index(active=True):
  """
    foot_index(active=True) -> double

    Returns the zero-based index of the foot of 
    an event in the active channel. The foot is the intersection of an
    interpolated line through the points of 20 and 80% rise with the
    baseline. Uses the currently measured values, i.e. does not update 
    measurements if the peak or base window cursors have changed.
       
    Arguments:
    active -- If True, returns the current index of the foot within the 
              active channel. Only implemented for the active channel
              at this time. Will return a negative value and show an 
              error message if active == False.
              
    Returns:
    The zero-based index of the foot of an event in units of sampling 
    points. Interpolates between sampling points.
    Returns a negative value upon failure.
    """
  return _stf.foot_index(active)
foot_index = _stf.foot_index
t50left_index_cb = _stf.t50left_index_cb

def t50left_index(active=True):
  """
    t50left_index(active=True) -> double

    Returns the zero-based index of the left half-
    maximal amplitude of an event in the specified channel. Uses the 
    currently measured values, i.e. does not update measurements if the 
    peak or base window cursors have changed.
       
    Arguments:
    active -- If True, returns the current index of the left half-
              maximal amplitude within the active channel. If False, 
              returns the current index of the left half-maximal amplitude
              within the reference channel.
              
    Returns:
    The zero-based index of the left half-maximal amplitude in units of 
    sampling points. Interpolates between sampling points. Returns a 
    negative value upon failure.
    """
  return _stf.t50left_index(active)
t50left_index = _stf.t50left_index
t50right_index_cb = _stf.t50right_index_cb

def t50right_index(active=True):
  """
    t50right_index(active=True) -> double

    Returns the zero-based index of the right half-
    maximal amplitude of an event in the active channel. Uses the 
    currently measured values, i.e. does not update measurements if the 
    peak or base window cursors have changed.
       
    Arguments:
    active -- If True, returns the current index of the right half-
              maximal amplitude within the active channel. Only 
              implemented for the active channel at this time. Will return 
              a negative value and show an error message if 
              active == False.
              
    Returns:
    The zero-based index of the right half-maximal amplitude in units of 
    sampling points. Interpolates between sampling points. Returns a 
    negative value upon failure.
    """
  return _stf.t50right_index(active)
t50right_index = _stf.t50right_index
get_halfwidth_cb = _stf.get_halfwidth_cb

def get_halfwidth(active=True):
  """
    get_halfwidth(active=True) -> double

    Returns the half-maximal amplitude of an event 
    in the specified channel. Uses the currently measured values, i.e. 
    does not update measurements if the peak or base window cursors have 
    changed. Only implemented for the active channel.
       
    Arguments:
    active -- If True, returns the current half-maximal amplitude within the 
              active channel. 
              
    Returns:
    The half-maximal amplitude in units of x-units. Returns a 
    negative value upon failure.
    """
  return _stf.get_halfwidth(active)
get_halfwidth = _stf.get_halfwidth
rtlow_index_cb = _stf.rtlow_index_cb

def rtlow_index(active=True):
  """
    rtlow_index(active=True) -> double

    Returns the zero-based index of the lower rise-
    time of an event in the specified channel. Uses the currently measured
    values, i.e. does not update measurements if the peak or base window
    cursors have changed.
       
    Arguments:
    active -- If True, returns the current index within the active
              channel. If False, returns the current index within the
              reference channel.
              
    Returns:
    The zero-based index of the lower rise time in units of sampling
    points. Interpolates between sampling points. Returns a negative value
    upon failure.
    """
  return _stf.rtlow_index(active)
rtlow_index = _stf.rtlow_index
rthigh_index_cb = _stf.rthigh_index_cb

def rthigh_index(active=True):
  """
    rthigh_index(active=True) -> double

    Returns the zero-based index of the higher
    rise time of an event in the specified channel. Uses the currently
    measured values, i.e. does not update measurements if the peak or base
    window cursors have changed.
       
    Arguments:
    active -- If True, returns the current index within the active
              channel. If False, returns the current index within the
              reference channel.
              
    Returns:
    The zero-based index of the higher rise time in units of sampling
    points. Interpolates between sampling points. Returns a negative value
    upon failure.
    """
  return _stf.rthigh_index(active)
rthigh_index = _stf.rthigh_index

def get_threshold_time(is_time=False):
  """
    get_threshold_time(is_time=False) -> double

    Returns the crossing value of the threshold 
    slope. Note that this value is not updated after changing the AP 
    threshold. Call measure() or hit enter to update the cursors.

    Arguments:
    is_time -- If False (default), returns the zero-based index at which 
               the threshold slope is crossed (e.g in mV). If True,
               returns the time point at which the threshold slope is 
               crossed. A negative number is returned upon failure. 

    """
  return _stf.get_threshold_time(is_time)
get_threshold_time = _stf.get_threshold_time

def get_latency():
  """
    get_latency() -> double

    Returns the latency value (in x-units)
    determined by the latency cursors set in the cursors settings menu. 
    Call measure() or hit enter to update the cursors.


    """
  return _stf.get_latency()
get_latency = _stf.get_latency

def get_risetime():
  """
    get_risetime() -> double

    Returns the rise time (in x-units)
    determined by the linear interpolation between sampling points
    (e.g at 20% and 80% of the peak amplitude. )
    Call measure() or hit enter to update the cursors.


    """
  return _stf.get_risetime()
get_risetime = _stf.get_risetime

def get_risetime_factor():
  """
    get_risetime_factor() -> double

    Returns the lower proportion factor used
    to calculate the rise time 
    (e.g 0.2 if we calculate the 20--80% rise time. )


    """
  return _stf.get_risetime_factor()
get_risetime_factor = _stf.get_risetime_factor

def set_risetime_factor(*args, **kwargs):
  """
    set_risetime_factor(factor) -> bool

    Sets the lower proportion factor
    to calculate the rise time
    (e.g 0.2 if we want to calculate the 20--80% rise time. )
    It will update the rise time measurement.

    Arguments:
    factor --  the low proportion factor to calculate rise time

    Returns:
    False upon failure (such as factor lower than 0.05 or larger than 0.5)

    """
  return _stf.set_risetime_factor(*args, **kwargs)
set_risetime_factor = _stf.set_risetime_factor

def get_threshold_value():
  """
    get_threshold_value() -> double

    Returns the value found at the threshold 
    slope. Note that this value is not updated after changing the AP 
    threshold. Call measure or hit enter to update the threshold.

    """
  return _stf.get_threshold_value()
get_threshold_value = _stf.get_threshold_value

def get_fit_start(is_time=False):
  """
    get_fit_start(is_time=False) -> double

    Returns the zero-based index or the time point
    of the fit start cursor.

    Arguments:
    is_time -- If False (default), returns the zero-based index. If True,
               returns the time from the beginning of the trace to the
               cursor position.          

    """
  return _stf.get_fit_start(is_time)
get_fit_start = _stf.get_fit_start

def get_fit_end(is_time=False):
  """
    get_fit_end(is_time=False) -> double

    Returns the zero-based index or the time point
    of the fit end cursor.

    Arguments:
    is_time -- If False (default), returns the zero-based index. If True,
               returns the time from the beginning of the trace to the
               cursor position.          

    """
  return _stf.get_fit_end(is_time)
get_fit_end = _stf.get_fit_end

def set_fit_start(*args, **kwargs):
  """
    set_fit_start(pos, is_time=False) -> bool

    Sets the fit start cursor to a new position.

    Arguments:
    pos --     The new cursor position, either in units of sampling points
               if is_time == False (default) or in units of time if
               is_time == True.
    is_time -- see above.

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_fit_start(*args, **kwargs)
set_fit_start = _stf.set_fit_start

def set_fit_end(*args, **kwargs):
  """
    set_fit_end(pos, is_time=False) -> bool

    Sets the fit end cursor to a new position.

    Arguments:
    pos --     The new cursor position, either in units of sampling points
               if is_time == False (default) or in units of time if
               is_time == True.
    is_time -- see above.

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_fit_end(*args, **kwargs)
set_fit_end = _stf.set_fit_end

def get_peak_start(is_time=False):
  """
    get_peak_start(is_time=False) -> double

    Returns the zero-based index or the time point
    of the peak start cursor.

    Arguments:
    is_time -- If False (default), returns the zero-based index. If True,
               returns the time from the beginning of the trace to the
               cursor position.          

    """
  return _stf.get_peak_start(is_time)
get_peak_start = _stf.get_peak_start

def get_peak_end(is_time=False):
  """
    get_peak_end(is_time=False) -> double

    Returns the zero-based index or the time point
    of the peak end cursor.

    Arguments:
    is_time -- If False (default), returns the zero-based index. If True,
               returns the time from the beginning of the trace to the
               cursor position.          

    """
  return _stf.get_peak_end(is_time)
get_peak_end = _stf.get_peak_end

def set_peak_start(*args, **kwargs):
  """
    set_peak_start(pos, is_time=False) -> bool

    Sets the peak start cursor to a new position.
    This will NOT update the peak calculation. You have to either call 
    measure() or hit enter in the main window to achieve that.

    Arguments:
    pos --     The new cursor position, either in units of sampling points
               if is_time == False (default) or in units of time if
               is_time == True.
    is_time -- see above.

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_peak_start(*args, **kwargs)
set_peak_start = _stf.set_peak_start

def set_peak_end(*args, **kwargs):
  """
    set_peak_end(pos, is_time=False) -> bool

    Sets the peak end cursor to a new position.
    This will NOT update the peak calculation. You have to either call 
    measure() or hit enter in the main window to achieve that.

    Arguments:
    pos --     The new cursor position, either in units of sampling points
               if is_time == False (default) or in units of time if
               is_time == True.
    is_time -- see above.

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_peak_end(*args, **kwargs)
set_peak_end = _stf.set_peak_end

def set_peak_mean(*args):
  """
    set_peak_mean(pts) -> bool

    Sets the number of points used for the peak 
    calculation.

    Arguments:
    pts -- A moving average (aka sliding, boxcar or running average) is 
           used to determine the peak value. Pts specifies the number of
           sampling points used for the moving window.
           Passing a value of -1 will calculate the average of all
           sampling points within the peak window.

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_peak_mean(*args)
set_peak_mean = _stf.set_peak_mean

def get_peak_mean():
  """
    get_peak_mean() -> int

    Returns the number of sampling points used for
    the peak calculation.

    Returns:
    0 upon failure (i.e no file opened). -1 means average of all sampling 
    points within the peak window.
    """
  return _stf.get_peak_mean()
get_peak_mean = _stf.get_peak_mean

def set_peak_direction(*args):
  """
    set_peak_direction(direction) -> bool

    Sets the direction of the peak detection.

    Arguments:
    direction -- A string specifying the peak direction. Can be one of:
                 "up", "down" or "both"

    Returns:
    False upon failure.
    """
  return _stf.set_peak_direction(*args)
set_peak_direction = _stf.set_peak_direction

def get_peak_direction():
  """
    get_peak_direction() -> char const *

    Gets the current direction of the detection
    for the peak cursors.

    Returns:
    A string specifying the peak direction. Can be one of:
    "up", "down" or "both"
    """
  return _stf.get_peak_direction()
get_peak_direction = _stf.get_peak_direction

def set_latency_start(*args, **kwargs):
  """
    set_latency_start(pos, is_time=False) -> bool

    Sets the first latency cursor to a new position.

    Arguments:
    pos --     The new cursor position, either in units of sampling points
               if is_time == False (default) or in units of time if
               is_time == True.
    is_time -- see above.

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_latency_start(*args, **kwargs)
set_latency_start = _stf.set_latency_start

def set_latency_start_mode(*args):
  """
    set_latency_start_mode(mode) -> bool

    Sets the mode of the latency start cursor.

    Arguments:
    direction -- A string specifying the mode for the latency start cursor. Can be one of "manual", "peak", "rise" or "half"

    Returns:
    False upon failure.
    """
  return _stf.set_latency_start_mode(*args)
set_latency_start_mode = _stf.set_latency_start_mode

def get_baseline_method():
  """
    get_baseline_method() -> char const *

    Gets the method used to compute the baseline

    Returns:
    A string specifying the method to compute the baseline. Can be one of
    "mean" or "median"
    """
  return _stf.get_baseline_method()
get_baseline_method = _stf.get_baseline_method

def set_baseline_method(*args):
  """
    set_baseline_method(method) -> bool

    Sets the method to compute the baseline.

    Arguments:
    method -- A string specifying the method to calculate the baseline.
                Can be one of "mean" or "median"

    Returns:
    False upon failure.
    """
  return _stf.set_baseline_method(*args)
set_baseline_method = _stf.set_baseline_method

def get_latency_start_mode():
  """
    get_latency_start_mode() -> char const *

    Gets the latency start mode

    Returns:
    A string specifying the latency start mode. Can be one of
    "manual", "peak", "rise" or "half"
    """
  return _stf.get_latency_start_mode()
get_latency_start_mode = _stf.get_latency_start_mode

def set_latency_end(*args, **kwargs):
  """
    set_latency_end(pos, is_time=False) -> bool

    Sets the second latency cursor to a new position.

    Arguments:
    pos --     The new cursor position, either in units of sampling points
               if is_time == False (default) or in units of time if
               is_time == True.
    is_time -- see above.

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_latency_end(*args, **kwargs)
set_latency_end = _stf.set_latency_end

def set_latency_end_mode(*args):
  """
    set_latency_end_mode(mode) -> bool

    Sets the mode of the latency end cursor.

    Arguments:
    direction -- A string specifying the mode for the latency end cursor. Can be one of
                 "manual", "peak", "rise", "foot" or "half"

    Returns:
    False upon failure.
    """
  return _stf.set_latency_end_mode(*args)
set_latency_end_mode = _stf.set_latency_end_mode

def get_latency_end_mode():
  """
    get_latency_end_mode() -> char const *

    Gets the latency end mode

    Returns:
    A string specifying the latency end mode. Can be one of "manual",
    "peak", "rise", "foot" or "half"
    """
  return _stf.get_latency_end_mode()
get_latency_end_mode = _stf.get_latency_end_mode

def get_latency_start(is_time=False):
  """
    get_latency_start(is_time=False) -> double

    Returns the zero-based index or the time point
    of the latency start cursor.

    Arguments:
    is_time -- If False (default), returns the zero-based index. If True,
               returns the time from the beginning of the trace to the
               cursor position.
    """
  return _stf.get_latency_start(is_time)
get_latency_start = _stf.get_latency_start

def get_latency_end(is_time=False):
  """
    get_latency_end(is_time=False) -> double

    Returns the zero-based index or the time point
    of the latency end cursor.

    Arguments:
    is_time -- If False (default), returns the zero-based index. If True,
               returns the time from the beginning of the trace to the
               cursor position.
    """
  return _stf.get_latency_end(is_time)
get_latency_end = _stf.get_latency_end

def get_base_SD():
  """
    get_base_SD() -> double

    Returns the standard deviation of the baseline
    in the current (active) channel. Uses the currently measured values,
    i.e. does not update measurements if the baseline cursors have changed. 

    Returns:
    0.0 upon failure (i.e no file opened), otherwise, the standard deviation
    of the baseline.
    """
  return _stf.get_base_SD()
get_base_SD = _stf.get_base_SD

def get_base_start(is_time=False):
  """
    get_base_start(is_time=False) -> double

    Returns the zero-based index or the time point
    of the base start cursor.

    Arguments:
    is_time -- If False (default), returns the zero-based index. If True,
               returns the time from the beginning of the trace to the
               cursor position.
    """
  return _stf.get_base_start(is_time)
get_base_start = _stf.get_base_start

def get_base_end(is_time=False):
  """
    get_base_end(is_time=False) -> double

    Returns the zero-based index or the time point
    of the base end cursor.

    Arguments:
    is_time -- If False (default), returns the zero-based index. If True,
               returns the time from the beginning of the trace to the
               cursor position.
    """
  return _stf.get_base_end(is_time)
get_base_end = _stf.get_base_end

def set_base_start(*args, **kwargs):
  """
    set_base_start(pos, is_time=False) -> bool

    Sets the base start cursor to a new position.
    This will NOT update the baseline calculation. You have to either call 
    measure() or hit enter in the main window to achieve that.

    Arguments:
    pos --     The new cursor position, either in units of sampling points
               if is_time == False (default) or in units of time if
               is_time == True.
    is_time -- see above.

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_base_start(*args, **kwargs)
set_base_start = _stf.set_base_start

def set_base_end(*args, **kwargs):
  """
    set_base_end(pos, is_time=False) -> bool

    Sets the base end cursor to a new position.
    This will NOT update the baseline calculation. You have to either call 
    measure() or hit enter in the main window to achieve that.

    Arguments:
    pos --     The new cursor position, either in units of sampling points
               if is_time == False (default) or in units of time if
               is_time == True.
    is_time -- see above.

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_base_end(*args, **kwargs)
set_base_end = _stf.set_base_end

def set_slope(*args):
  """
    set_slope(slope) -> bool

    Sets the AP threshold to the value given by the
    slope and takes it as reference for AP kinetic measurements. Note that 
    you have to either call measure() or hit enter to update calculations.

    Arguments:
    slope --  slope value in mV/ms  

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_slope(*args)
set_slope = _stf.set_slope

def measure():
  """
    measure() -> bool

    Updates all measurements (e.g. peak, baseline, 
    latency) according to the current cursor settings. As if you had
    pressed "Enter" in the main window.
    Returns:
    False upon failure, True otherwise.
    """
  return _stf.measure()
measure = _stf.measure

def get_selected_indices():
  """
    get_selected_indices() -> PyObject *

    Returns a tuple with the indices (ZERO-BASED) 
    of the selected traces.
    """
  return _stf.get_selected_indices()
get_selected_indices = _stf.get_selected_indices

def set_trace(*args):
  """
    set_trace(trace) -> bool

    Sets the currently displayed trace to a new
    index. Subsequently updates all measurements (e.g. peak, base,
    latency, i.e. you don't need to call measure() yourself.)

    Arguments:
    trace -- The zero-based index of the new trace to be displayed.

    Returns:
    True upon success, false otherwise (such as out-of-range).
    """
  return _stf.set_trace(*args)
set_trace = _stf.set_trace

def get_trace_index():
  """
    get_trace_index() -> int

    Returns the ZERO-BASED index of the currently
    displayed trace (this is one less than what is shown in the combo box).

    """
  return _stf.get_trace_index()
get_trace_index = _stf.get_trace_index

def get_channel_index(active=True):
  """
    get_channel_index(active=True) -> int

    Returns the ZERO-BASED index of the specified
    channel.

    Arguments:

    active -- If True, returns the index of the active (black) channel.
    If False, returns the index of the reference (red) channel.

    """
  return _stf.get_channel_index(active)
get_channel_index = _stf.get_channel_index

def get_channel_name(*args, **kwargs):
  """
    get_channel_name(index=-1) -> char const *

    Returns the name of the channel with the 
    specified index.

    Arguments:

    index -- The zero-based index of the channel of interest. If < 0, the
          	 name of the active channel will be returned.

    Returns:
    the name of the channel with the specified index.
    """
  return _stf.get_channel_name(*args, **kwargs)
get_channel_name = _stf.get_channel_name

def set_channel(*args):
  """
    set_channel(channel) -> bool

    Sets the currently displayed channel to a new
    index. Subsequently updates all measurements (e.g. peak, base,
    latency, i.e. you don't need to call measure() yourself.)

    Arguments:
    channel -- The zero-based index of the new trace to be displayed.

    Returns:
    True upon success, false otherwise (such as out-of-range).
    """
  return _stf.set_channel(*args)
set_channel = _stf.set_channel

def set_channel_name(*args, **kwargs):
  """
    set_channel_name(name, index=-1) -> bool

    Sets the name of the channel with the 
    specified index.

    Arguments:
    name  -- The new name of the channel.
    index -- The zero-based index of the channel of interest. If < 0, the
          	 active channel will be used.

    Returns:
    True upon success.
    """
  return _stf.set_channel_name(*args, **kwargs)
set_channel_name = _stf.set_channel_name

def get_trace_name(*args, **kwargs):
  """
    get_trace_name(trace=-1, channel=-1) -> char const *

    Returns the name of the trace with the 
    specified index.

    Arguments:
    trace -- The zero-based index of the trace of interest. If < 0, the
          	   name of the active trace will be returned.
    channel -- The zero-based index of the channel of interest. If < 0, the
          	   active channel will be used.

    Returns:
    the name of the trace with the specified index.
    """
  return _stf.get_trace_name(*args, **kwargs)
get_trace_name = _stf.get_trace_name

def align_selected(*args, **kwargs):
  """
    align_selected(alignment, active=False)

    Aligns the selected traces to the index that is 
    returned by the alignment function, and then creates a new window 
    showing the aligned traces. This function requires to select the
    traces of interest and the presence of a second (i.e reference) channel.
    Arguments:       
    alignment -- The alignment function to be used. Accepts any function
                 returning a valid index within a trace. These are some
                 predefined possibilities:
                 maxrise_index (default; maximal slope during rising phase)
                 peak_index (Peak of an event)
                 foot_index (Beginning of an event)
                 t50left_index 
                 t50right_index (Left/right half-maximal amplitude)
    active --    If True, the alignment function will be applied to
                 the active channel. If False (default), it will be applied
                 to the reference channel.
    zeropad --   Not yet implemented:
                 If True, missing parts at the beginning or end of a trace 
                 will be padded with zeros after the alignment. If False
                 (default), traces will be cropped so that all traces have
                 equal sizes.

    """
  return _stf.align_selected(*args, **kwargs)
align_selected = _stf.align_selected

def set_marker(*args):
  """
    set_marker(x, y) -> bool

    Sets a marker to the specified position in the
    current trace.

    Arguments:
    x -- The horizontal marker position in units of sampling points.
    y -- The vertical marker position in measurement units (e.g. mV).

    Returns:
    False upon failure (such as out-of-range).
    """
  return _stf.set_marker(*args)
set_marker = _stf.set_marker

def erase_markers():
  """erase_markers() -> bool"""
  return _stf.erase_markers()
erase_markers = _stf.erase_markers

def plot_xmin():
  """
    plot_xmin() -> double

    Returns x value of the left screen border
    """
  return _stf.plot_xmin()
plot_xmin = _stf.plot_xmin

def plot_xmax():
  """
    plot_xmax() -> double

    Returns x value of the right screen border
    """
  return _stf.plot_xmax()
plot_xmax = _stf.plot_xmax

def plot_ymin():
  """
    plot_ymin() -> double

    Returns y value of the bottom screen border
    """
  return _stf.plot_ymin()
plot_ymin = _stf.plot_ymin

def plot_ymax():
  """
    plot_ymax() -> double

    Returns y value of the top screen border
    """
  return _stf.plot_ymax()
plot_ymax = _stf.plot_ymax

def plot_y2min():
  """
    plot_y2min() -> double

    Returns y value of the bottom screen border for
    the reference channel
    """
  return _stf.plot_y2min()
plot_y2min = _stf.plot_y2min

def plot_y2max():
  """
    plot_y2max() -> double

    Returns y value of the top screen border for
    the reference channel
    """
  return _stf.plot_y2max()
plot_y2max = _stf.plot_y2max

def mpl_panel(*args, **kwargs):
  """
    mpl_panel(figsize=std::vector< double >(_figsize, _figsize+2)) -> PyObject *

    Returns a pointer to the parent window
    """
  return _stf.mpl_panel(*args, **kwargs)
mpl_panel = _stf.mpl_panel
class StfException(Exception):
    """ raises Exceptions for the Stfio module """
    def __init__(self, error_msg):
        self.msg = error_msg 

    def __str__(self):
        return repr(self.msg)

def new_window_list( array_list ):
    """Creates a new window showing a sequence of
    1D NumPy arrays, or a sequence of a sequence of 1D
    NumPy arrays. As opposed to new_window_matrix(), this
    has the advantage that the arrays need not have equal sizes.
      
    Arguments:       
    array_list -- A sequence (e.g. list or tuple) of numpy arrays, or
                  a sequence of a sequence of numpy arrays.

    Returns:
    True upon successful completion, false otherwise.
    """
    try: 
        it = iter(array_list)
    except TypeError: 
        print( "Argument is not a sequence" )
        return False

    try: 
        it = iter(array_list[0])
    except TypeError: 
        print( "Argument is not a sequence of sequences." )
        print( "You can either pass a sequence of 1D NumPy arrays," )
        print( "Or a sequence of sequences of 1D NumPy arrays." )
        return False
        
    is_3d = True
    try: 
        it = iter(array_list[0][0])
    except TypeError: 
        is_3d = False
        n_channels = 1

    if is_3d:
        n_channels = len(array_list)
        _gMatrix_resize( n_channels, len(array_list[0]) )
        for (n_c, c) in enumerate(array_list):
            for (n_s, s) in enumerate(c):
                _gMatrix_at( s, n_c, n_s )
        
    else:
        _gMatrix_resize( n_channels, len(array_list) )
        for (n, a) in enumerate(array_list):
            _gMatrix_at( a, 0, n )

    return _new_window_gMatrix( )

def stfio_open(stfio_rec):
    """Open an stfio recording object with Stimfit

    Arguments:
    stfio_rec  -- An stfio recording object, e.g. opened with
                  stfio.read("filename")

    Returns:
    True upon successful completion, false otherwise.
    """
    n_channels = len(stfio_rec)
    _gMatrix_resize( n_channels, len(stfio_rec[0]) )
    for n_c, c in enumerate(stfio_rec):
        for n_s, s in enumerate(c):
            _gMatrix_at( c[n_s].asarray(), n_c, n_s )

    succ = _new_window_gMatrix( )
    if not succ:
        return False

    for n_c, c in enumerate(stfio_rec):
        set_channel_name(c.name, n_c)
        set_yunits(c.yunits, n_c)

    set_recording_date(stfio_rec.date)
    set_recording_time(stfio_rec.time)
    set_recording_comment(stfio_rec.comment)
    set_xunits(stfio_rec.xunits)
    set_sampling_interval(stfio_rec.dt)
    measure()

    return True

def cut_traces( pt ):
    """Cuts the selected traces at the sampling point pt,
    and shows the cut traces in a new window.
    Returns True upon success, False upon failure."""
    
    if not get_selected_indices():
        print( "Trace is not selected!" )
        return False
    new_list = list()
    for n in get_selected_indices():
        if not set_trace(n): return False
        
        if pt < get_size_trace():
            new_list.append( get_trace()[:pt] )
            new_list.append( get_trace()[pt:] )
        else:
            print( "Cutting point %d is out of range" %pt )

    if len(new_list) > 0: new_window_list( new_list )
    
    return True
    
def cut_traces_multi( pt_list ):
    """Cuts the selected traces at the sampling points
    in pt_list and shows the cut traces in a new window.
    Returns True upon success, False upon failure."""
    if not get_selected_indices():
        print( "Trace is not selected!" )
        return False
    new_list = list()
    for n in get_selected_indices():
        if not set_trace(n): return False
        old_pt = 0
        for pt in pt_list:
            if pt < get_size_trace():
                new_list.append( get_trace()[old_pt:pt] )
                old_pt = pt
            else:
                print( "Cutting point %d is out of range" %pt )
        if len(new_list) > 0: new_list.append( get_trace()[old_pt:] )
    new_window_list( new_list )
    return True

def template_matching(template, mode="criterion", norm=True, lowpass=0.5, highpass=0.0001):
    import sys
    sys.stderr.write("template_matching is deprecated. Use detect_events instead.\n")
    return detect_events(template, mode, norm, lowpass, highpass)

def detect_events(template, mode="criterion", norm=True, lowpass=0.5, highpass=0.0001):
    if not check_doc():
        return None
    import stfio
    return stfio.detect_events(get_trace(), template, get_sampling_interval(),
                               mode, norm, lowpass, highpass)

def peak_detection(data, threshold, min_distance):
    import stfio
    return stfio.peak_detection(data, threshold, min_distance)

class _cursor_pair(object):
    def __init__(self, get_start, set_start, get_end, set_end, get_value=None, index=None):
        self._get_start = get_start
        self._set_start = set_start
        self._get_end = get_end
        self._set_end = set_end
        self._get_value = get_value
        self._index = index

    def _get_cursors(self, is_time):
        if not check_doc(show_dialog=False):            
            raise StfException("Couldn't find open file")
        return (self._get_start(is_time=is_time), self._get_end(is_time=is_time))

    def _set_cursors(self, cursors, is_time):
        if not check_doc(show_dialog=False):            
            raise StfException("Couldn't find open file")
        try:
            if len(cursors) != 2:
                raise ValueError("cursors has to have length 2 when setting the time value")
        except TypeError:
            raise TypeError("cursors has to be a tuple or list of length 2")
        if cursors[0] is not None:
            self._set_start(cursors[0], is_time=is_time)
        if cursors[1] is not None:
            self._set_end(cursors[1], is_time=is_time)

    @property
    def cursor_time(self):
        return self._get_cursors(True)

    @cursor_time.setter
    def cursor_time(self, cursors):
        self._set_cursors(cursors, True)

    @property
    def cursor_index(self):
        return self._get_cursors(False)

    @cursor_index.setter
    def cursor_index(self, cursors):
        self._set_cursors(cursors, False)

    @property
    def value(self):
        if self._get_value is None:
            raise AttributeError("Missing _get_value function")
        return self._get_value()

    @property
    def index(self):
        if self._index is None:
            raise AttributeError("Missing _index function")
        return self._index()

    
base = _cursor_pair(get_base_start, set_base_start, get_base_end, set_base_end,
                    get_base)
peak = _cursor_pair(get_peak_start, set_peak_start, get_peak_end, set_peak_end,
                    get_peak, peak_index)
fit = _cursor_pair(get_fit_start, set_fit_start, get_fit_end, set_fit_end)

latency = _cursor_pair(get_latency_start, set_latency_start, get_latency_end, set_latency_end)


# This file is compatible with both classic and new-style classes.


